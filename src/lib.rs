use rand::random;
use sha2::{Digest, Sha256};

const D_PBLC: u16 = 0x8080;
const D_MESG: u16 = 0x8181;
const D_LEAF: u16 = 0x8282;
const D_INTR: u16 = 0x8383;

type LMSResult<T> = Result<T, String>;

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct HashValue<const N: usize>([u8; N]);

impl<const N: usize> Default for HashValue<N> {
    fn default() -> Self {
        let data = [0u8; N];
        HashValue(data)
    }
}

impl<const N: usize> From<[u8; N]> for HashValue<N> {
    fn from(data: [u8; N]) -> Self {
        HashValue(data)
    }
}

impl From<[u8; 32]> for HashValue<24> {
    fn from(data: [u8; 32]) -> Self {
        let mut t = [0u8; 24];
        t[..24].copy_from_slice(&data[..24]);
        HashValue(t)
    }
}

impl<const N: usize> AsRef<[u8]> for HashValue<N> {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

pub type Sha256Digest = HashValue<32>;
pub type Sha192Digest = HashValue<24>;
pub type LmsIdentifier = [u8; 16];

pub fn slice_to_num(buff: &[u8]) -> u32 {
    u32::from_be_bytes(buff.try_into().unwrap())
}

#[derive(Debug)]
pub struct LmsPublicKey<const N: usize> {
    pub lms_identifier: LmsIdentifier,
    pub root_hash: HashValue<N>,
    pub lms_type: LmsAlgorithmType,
    pub lmots_type: LmotsAlgorithmType,
}

pub struct LmsTree<const N: usize> {
    pub lms_identifier: LmsIdentifier,
    pub q: u32,
    pub t_tree: Vec<HashValue<N>>,
    pub private_keys: Vec<Vec<HashValue<N>>>,
}

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum LmotsAlgorithmType {
    LmotsReserved = 0,
    LmotsSha256N32W1 = 1,
    LmotsSha256N32W2 = 2,
    LmotsSha256N32W4 = 3,
    LmotsSha256N32W8 = 4,
    LmotsSha256N24W1 = 5,
    LmotsSha256N24W2 = 6,
    LmotsSha256N24W4 = 7,
    LmotsSha256N24W8 = 8,
}

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum LmsAlgorithmType {
    LmsReserved = 0,
    LmsSha256N32H5 = 5,
    LmsSha256N32H10 = 6,
    LmsSha256N32H15 = 7,
    LmsSha256N32H20 = 8,
    LmsSha256N32H25 = 9,
    LmsSha256N24H5 = 10,
    LmsSha256N24H10 = 11,
    LmsSha256N24H15 = 12,
    LmsSha256N24H20 = 13,
    LmsSha256N24H25 = 14,
}

#[derive(Debug)]
pub struct LmotsSignature<const N: usize> {
    pub ots_type: LmotsAlgorithmType,
    pub nonce: [u8; N],
    pub y: Vec<HashValue<N>>,
}

#[derive(Debug)]
pub struct LmsSignature<const N: usize> {
    pub q: u32,
    pub ots_type: LmotsAlgorithmType,
    pub nonce: [u8; N],
    pub y: Vec<HashValue<N>>,
    pub lms_type: LmsAlgorithmType,
    pub path: Vec<HashValue<N>>,
}

#[derive(Debug)]
pub struct LmotsParameter {
    pub algorithm_name: LmotsAlgorithmType,
    pub n: u8,
    pub w: u8,
    pub p: u16,
    pub ls: u8,
}

const LMOTS_P: [LmotsParameter; 9] = [
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsReserved,
        n: 0,
        w: 0,
        p: 0,
        ls: 0,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W1,
        n: 32,
        w: 1,
        p: 265,
        ls: 7,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W2,
        n: 32,
        w: 2,
        p: 133,
        ls: 6,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W4,
        n: 32,
        w: 4,
        p: 67,
        ls: 4,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W8,
        n: 32,
        w: 8,
        p: 34,
        ls: 0,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W1,
        n: 24,
        w: 1,
        p: 200,
        ls: 8,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W2,
        n: 24,
        w: 2,
        p: 101,
        ls: 6,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W4,
        n: 24,
        w: 4,
        p: 51,
        ls: 4,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W8,
        n: 24,
        w: 8,
        p: 26,
        ls: 0,
    },
];

pub fn get_lmots_parameters(algo_type: &LmotsAlgorithmType) -> LMSResult<&'static LmotsParameter> {
    for i in &LMOTS_P {
        if i.algorithm_name == *algo_type {
            return Ok(i);
        }
    }
    Err("Unable to find the parameters".to_string())
}

pub fn get_lms_parameters(algo_type: &LmsAlgorithmType) -> LMSResult<(u8, u8)> {
    match algo_type {
        LmsAlgorithmType::LmsSha256N32H5 => Ok((32, 5)),
        LmsAlgorithmType::LmsSha256N32H10 => Ok((32, 10)),
        LmsAlgorithmType::LmsSha256N32H15 => Ok((32, 15)),
        LmsAlgorithmType::LmsSha256N32H20 => Ok((32, 20)),
        LmsAlgorithmType::LmsSha256N32H25 => Ok((32, 25)),
        LmsAlgorithmType::LmsSha256N24H5 => Ok((24, 5)),
        LmsAlgorithmType::LmsSha256N24H10 => Ok((24, 10)),
        LmsAlgorithmType::LmsSha256N24H15 => Ok((24, 15)),
        LmsAlgorithmType::LmsSha256N24H20 => Ok((24, 20)),
        LmsAlgorithmType::LmsSha256N24H25 => Ok((24, 25)),
        LmsAlgorithmType::LmsReserved => Err("Reserved LMS has no parameters".to_string()),
    }
}

pub fn lookup_lms_algorithm_type(alg_value: u32) -> LMSResult<LmsAlgorithmType> {
    // take in a 32 bit value and return the corresponding LMS algorithm type
    match alg_value {
        5 => Ok(LmsAlgorithmType::LmsSha256N32H5),
        6 => Ok(LmsAlgorithmType::LmsSha256N32H10),
        7 => Ok(LmsAlgorithmType::LmsSha256N32H15),
        8 => Ok(LmsAlgorithmType::LmsSha256N32H20),
        9 => Ok(LmsAlgorithmType::LmsSha256N32H25),
        10 => Ok(LmsAlgorithmType::LmsSha256N24H5),
        11 => Ok(LmsAlgorithmType::LmsSha256N24H10),
        12 => Ok(LmsAlgorithmType::LmsSha256N24H15),
        13 => Ok(LmsAlgorithmType::LmsSha256N24H20),
        14 => Ok(LmsAlgorithmType::LmsSha256N24H25),
        _ => Err("Unknown LMS algorithm type".to_string()),
    }
}

pub fn lookup_lmots_algorithm_type(alg_value: u32) -> LMSResult<LmotsAlgorithmType> {
    // take in a 32 bit value and return the corresponding LMOTS algorithm type
    match alg_value {
        1 => Ok(LmotsAlgorithmType::LmotsSha256N32W1),
        2 => Ok(LmotsAlgorithmType::LmotsSha256N32W2),
        3 => Ok(LmotsAlgorithmType::LmotsSha256N32W4),
        4 => Ok(LmotsAlgorithmType::LmotsSha256N32W8),
        5 => Ok(LmotsAlgorithmType::LmotsSha256N24W1),
        6 => Ok(LmotsAlgorithmType::LmotsSha256N24W2),
        7 => Ok(LmotsAlgorithmType::LmotsSha256N24W4),
        8 => Ok(LmotsAlgorithmType::LmotsSha256N24W8),
        _ => Err("Unknown LMOTS algorithm type".to_string()),
    }
}

// follows pseudo code at https://www.rfc-editor.org/rfc/rfc8554#section-3.1.3
fn coefficient(s: &[u8], i: usize, w: usize) -> LMSResult<u8> {
    let valid_w = matches!(w, 1 | 2 | 4 | 8);
    if !valid_w {
        return Err("Invalid w value".to_string());
    }
    let bitmask: u16 = (1 << (w)) - 1;
    let index = i * w / 8;
    if index >= s.len() {
        return Err("Index out of bounds".to_string());
    }
    let b = s[index];

    // extra logic to avoid the divide by 0
    // which a good compiler would notice only happens when w is 0 and that portion of the
    // expression could be skipped
    let mut shift = 8;
    if w != 0 {
        shift = 8 - (w * (i % (8 / w)) + w);
    }

    // Rust errors if we try to shift off all of the bits off from a value
    // some implementations 0 fill, others do some other filling.
    // we make this be 0
    let mut rs = 0;
    if shift < 8 {
        rs = b >> shift;
    }
    let small_bitmask = bitmask as u8;
    Ok(small_bitmask & rs)
}

fn create_lmots_private_key<const N: usize>(
    algo_type: &LmotsAlgorithmType,
) -> LMSResult<Vec<HashValue<N>>> {
    let params = get_lmots_parameters(algo_type)?;
    let mut x = vec![];
    if N > 32 {
        return Err(
            "Error generating private key, currently defined for a max of 32 bytes".to_string(),
        );
    }
    for _ in 0..params.p {
        let t_tmp: [u8; 32] = random();
        let mut tmp: [u8; N] = [0u8; N];
        tmp[..N].copy_from_slice(&t_tmp[..N]);
        x.push(HashValue::<N>::from(tmp));
    }
    Ok(x)
}

fn calculate_ots_public_key<const N: usize>(
    algo_type: &LmotsAlgorithmType,
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
    x: &[HashValue<N>],
) -> LMSResult<HashValue<N>> {
    let params = get_lmots_parameters(algo_type)?;
    assert_eq!(params.n as usize, N);
    let mut y = vec![];
    for (i, xi) in x.iter().enumerate() {
        let mut tmp = *xi;
        let upper = (1 << params.w) - 1;
        for j in 0..upper {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(q);
            hasher.update((i as u16).to_be_bytes());
            hasher.update((j as u8).to_be_bytes());
            hasher.update(tmp);
            let t_buf = hasher.finalize();
            let mut buf = [0u8; N];
            buf[..N].copy_from_slice(&t_buf[..N]);
            tmp = HashValue::<N>::from(buf);
        }
        y.push(tmp);
    }
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(D_PBLC.to_be_bytes());
    for t in y {
        hasher.update(t);
    }
    let t_buf = hasher.finalize();
    let mut buf = [0u8; N];
    buf[..N].copy_from_slice(&t_buf[..N]);
    let return_value = HashValue::<N>::from(buf);
    Ok(return_value)
}

// this is derived from section 5.2 of rfc 8554
fn create_lms_private_keys<const N: usize>(
    tree_height: u8,
    ots_type: &LmotsAlgorithmType,
) -> LMSResult<(LmsIdentifier, u32, Vec<Vec<HashValue<N>>>)> {
    let lms_identifier: LmsIdentifier = random();
    let upper = 1 << tree_height;
    let mut ots_private = vec![];
    for _ in 0..upper {
        ots_private.push(create_lmots_private_key(ots_type)?);
    }
    Ok((lms_identifier, 0, ots_private))
}

pub fn create_lms_tree<const N: usize>(
    lms_type: &LmsAlgorithmType,
    ots_type: &LmotsAlgorithmType,
) -> LMSResult<(LmsPublicKey<N>, LmsTree<N>)> {
    let (hash_size, tree_height) = get_lms_parameters(lms_type)?;
    if hash_size as usize != N {
        return Err("Hash size does not match".to_string());
    }
    let num_nodes = 1 << (tree_height + 1); // we will instantiate an array to store the entire tree
    let mut t_tree = vec![HashValue::<N>::default(); num_nodes]; // the tree root will be at t_tree[1]
    let (lms_identifier, initial_q, private_keys) = create_lms_private_keys(tree_height, ots_type)?;
    if num_nodes != 2 * private_keys.len() {
        return Err(
            "The tree needs to be twice the size of the number of private keys".to_string(),
        );
    }
    // Copy the public keys of the leaves into the leaves of the tree
    let initial_offset = private_keys.len();
    for offset in 0..private_keys.len() {
        let q = (offset as u32).to_be_bytes();
        let ots_key =
            calculate_ots_public_key(ots_type, &lms_identifier, &q, &private_keys[offset])?;
        let mut hasher = Sha256::new();
        hasher.update(lms_identifier);
        let r = (initial_offset + offset) as u32;
        hasher.update(r.to_be_bytes());
        hasher.update(D_LEAF.to_be_bytes());
        hasher.update(ots_key);
        let t_buf = hasher.finalize();
        let mut buf = [0u8; N];
        buf[..N].copy_from_slice(&t_buf[..N]);
        t_tree[initial_offset + offset] = HashValue::<N>::from(buf);
    }
    // Now process each layer of tree from the bottom up
    for level in (1..(tree_height + 1)).rev() {
        let initial_offset = 1 << (level - 1);
        for offset in 0..initial_offset {
            let node_num: u32 = offset + initial_offset;
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(node_num.to_be_bytes());
            hasher.update(D_INTR.to_be_bytes());
            hasher.update(t_tree[2 * node_num as usize]);
            hasher.update(t_tree[(2 * node_num) as usize + 1]);
            let t_buf = hasher.finalize();
            let mut buf = [0u8; N];
            buf[..N].copy_from_slice(&t_buf[..N]);
            t_tree[node_num as usize] = HashValue::<N>::from(buf);
        }
    }

    let lms_public_key = LmsPublicKey::<N> {
        lms_identifier,
        root_hash: t_tree[1],
        lms_type: *lms_type,
        lmots_type: *ots_type,
    };
    let lms_tree = LmsTree::<N> {
        lms_identifier,
        q: initial_q,
        t_tree,
        private_keys,
    };
    Ok((lms_public_key, lms_tree))
}

fn checksum(algo_type: &LmotsAlgorithmType, input_string: &[u8]) -> LMSResult<u16> {
    let params = get_lmots_parameters(algo_type)?;
    let valid_w = matches!(params.w, 1 | 2 | 4 | 8);
    if !valid_w {
        return Err("Invalid w value".to_string());
    }
    let mut sum = 0u16;
    let upper_bound = params.n as u16 * (8 / params.w as u16);
    for i in 0..upper_bound {
        sum = sum + ((1 << params.w) - 1)
            - (coefficient(input_string, i as usize, params.w as usize)? as u16);
    }
    Ok(sum << params.ls)
}

fn lmots_sign_message<const N: usize>(
    algo_type: &LmotsAlgorithmType,
    input_string: &[u8],
    private_key: &Vec<HashValue<N>>,
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
) -> LMSResult<LmotsSignature<N>> {
    let params = get_lmots_parameters(algo_type)?;
    assert_eq!(params.n as usize, N);
    let nonce_t: [u8; 32] = random(); // in the RFC this is the C value
    let mut nonce = [0u8; N];
    nonce[..N].copy_from_slice(&nonce_t[..N]);

    let mut y = vec![];
    assert_eq!(private_key.len(), params.p as usize);
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(D_MESG.to_be_bytes());
    hasher.update(nonce);
    hasher.update(input_string);
    let tq = hasher.finalize();
    let mut message_hash_with_checksum = [0u8; 34]; // needs to be N + 2 extra bytes for the checksum.
    for (index, b) in tq.iter().enumerate() {
        message_hash_with_checksum[index] = *b;
    }
    let checksum_q = checksum(algo_type, &message_hash_with_checksum)?;
    let be_checksum = checksum_q.to_be_bytes();
    message_hash_with_checksum[N] = be_checksum[0];
    message_hash_with_checksum[N + 1] = be_checksum[1];

    for i in 0..params.p {
        let a = coefficient(&message_hash_with_checksum, i as usize, params.w as usize)?;
        let mut tmp = private_key[i as usize];
        for j in 0..a {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(q);
            hasher.update(i.to_be_bytes());
            hasher.update(j.to_be_bytes());
            hasher.update(tmp);
            let t_buf = hasher.finalize();
            let mut buf = [0u8; N];
            buf[..N].copy_from_slice(&t_buf[..N]);
            tmp = HashValue::<N>::from(buf);
        }
        y.push(tmp);
    }

    let signature = LmotsSignature {
        ots_type: *algo_type,
        nonce,
        y,
    };
    Ok(signature)
}

fn candidate_ots_signature<const N: usize>(
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
    signature: &LmotsSignature<N>,
    message: &[u8],
) -> LMSResult<HashValue<N>> {
    let params = get_lmots_parameters(&signature.ots_type)?;
    assert!(params.n < 33);
    let mut hasher = Sha256::new();
    let mut z = vec![];
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(D_MESG.to_be_bytes());
    hasher.update(signature.nonce);
    hasher.update(message);
    let tq = hasher.finalize();
    let mut message_hash_with_checksum = [0u8; 34]; // 2 extra bytes for the checksum. needs to be N+2
    for (index, b) in tq.iter().enumerate() {
        message_hash_with_checksum[index] = *b;
    }
    let checksum_q = checksum(&signature.ots_type, &message_hash_with_checksum)?;
    let be_checksum = checksum_q.to_be_bytes();
    message_hash_with_checksum[N] = be_checksum[0];
    message_hash_with_checksum[N + 1] = be_checksum[1];

    for i in 0..params.p {
        let a = coefficient(&message_hash_with_checksum, i as usize, params.w as usize)?;
        let mut tmp = signature.y[i as usize];
        let t_upper: u16 = (1 << params.w) - 1; // subtract with overflow?
        let upper = t_upper as u8;
        for j in a..upper {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(q);
            hasher.update(i.to_be_bytes());
            hasher.update(j.to_be_bytes());
            hasher.update(tmp);
            let t_buf = hasher.finalize();
            let mut buf = [0u8; N];
            buf[..N].copy_from_slice(&t_buf[..N]);
            tmp = HashValue::<N>::from(buf);
        }
        z.push(tmp);
    }
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(D_PBLC.to_be_bytes());
    for t in z {
        hasher.update(t);
    }
    let t_buf = hasher.finalize();
    let mut buf = [0u8; N];
    buf[..N].copy_from_slice(&t_buf[..N]);
    let result = HashValue::<N>::from(buf);
    Ok(result)
}

pub fn verify_ots_signature<const N: usize>(
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
    public_key: &HashValue<N>,
    signature: &LmotsSignature<N>,
    message: &[u8],
) -> LMSResult<bool> {
    let final_result = candidate_ots_signature(lms_identifier, q, signature, message)?;

    if final_result != *public_key {
        return Ok(false);
    }
    Ok(true)
}

pub fn parse_public_contents<const N: usize>(public_string: &[u8]) -> LMSResult<LmsPublicKey<N>> {
    if public_string.len() != (24 + N) {
        return Err("Public key string is the wrong size".to_string());
    }
    let mut pos = 0;
    let lms_type = lookup_lms_algorithm_type(slice_to_num(&public_string[pos..pos + 4]))?;
    pos += 4;

    let lmots_type = lookup_lmots_algorithm_type(slice_to_num(&public_string[pos..pos + 4]))?;
    pos += 4;

    let (hash_width, _) = get_lms_parameters(&lms_type)?;
    if hash_width as usize != N {
        return Err(
            "Hash width specified in the LMS type does not match the const N provided".to_string(),
        );
    }

    let mut lms_identifier = [0u8; 16];
    lms_identifier.copy_from_slice(&public_string[pos..pos + 16]);
    pos += 16;

    let mut temp = [0u8; N];
    temp.copy_from_slice(&public_string[pos..pos + N]);
    let public_hash = HashValue::<N>::from(temp);

    let pk = LmsPublicKey {
        lms_type,
        lmots_type,
        lms_identifier,
        root_hash: public_hash,
    };
    Ok(pk)
}

pub fn parse_signature_contents<const N: usize>(signature: &[u8]) -> LMSResult<LmsSignature<N>> {
    if signature.len() < 8 {
        return Err("Signature string is too short".to_string());
    }
    let mut pos = 0;
    let q = slice_to_num(&signature[pos..pos + 4]);
    pos += 4;

    let ots_type = lookup_lmots_algorithm_type(slice_to_num(&signature[pos..pos + 4]))?;
    pos += 4;
    let lmots_params = get_lmots_parameters(&ots_type)?;
    if lmots_params.n as usize != N {
        return Err("LMOTS hash width does not match the const parameter provided".to_string());
    }

    let signature_size_before_path = 8 + N + (lmots_params.p as usize * N) + 4;
    if signature.len() < signature_size_before_path {
        return Err("Signature string is too short".to_string());
    }

    let mut nonce = [0u8; N];
    nonce.copy_from_slice(&signature[pos..pos + N]);
    pos += N;

    let mut y = vec![];
    for _ in 0..lmots_params.p {
        let mut tmp = [0u8; N];
        tmp.copy_from_slice(&signature[pos..pos + N]);
        y.push(HashValue::<N>::from(tmp));
        pos += N;
    }
    let lms_type = lookup_lms_algorithm_type(slice_to_num(&signature[pos..pos + 4]))?;
    pos += 4;

    let (hash_width, height) = get_lms_parameters(&lms_type)?;
    if N != hash_width as usize {
        return Err("Hash sizes do not match".to_string());
    }

    if (height as usize * N) + pos > signature.len() {
        return Err("Signature is too short".to_string());
    }

    let mut path = vec![];
    for _ in 0..height {
        let mut tmp = [0u8; N];
        tmp.copy_from_slice(&signature[pos..pos + N]);
        path.push(HashValue::<N>::from(tmp));
        pos += N;
    }
    let lms_sig = LmsSignature {
        q,
        ots_type,
        nonce,
        y,
        lms_type,
        path,
    };
    Ok(lms_sig)
}

pub fn lms_sign_message<const N: usize>(
    algo_type: &LmotsAlgorithmType,
    lms_algorithm: &LmsAlgorithmType,
    input_string: &[u8],
    private_key: &Vec<HashValue<N>>,
    q: u32,
    lms_tree: &LmsTree<N>,
) -> LMSResult<LmsSignature<N>> {
    let (_, tree_height) = get_lms_parameters(lms_algorithm)?;
    if q >= (1 << tree_height) {
        return Err("q is too large".to_string());
    }
    let lmots_sig = lmots_sign_message(
        algo_type,
        input_string,
        private_key,
        &lms_tree.lms_identifier,
        &q.to_be_bytes(),
    )?;
    let mut path = vec![];

    let mut node_num = (1 << tree_height) + q;
    let mut sibling = node_num ^ 1;
    path.push(lms_tree.t_tree[sibling as usize]);
    for _ in 1..tree_height {
        node_num >>= 1;
        sibling = node_num ^ 1;
        path.push(lms_tree.t_tree[sibling as usize]);
    }
    let signature = LmsSignature {
        q,
        lms_type: *lms_algorithm,
        ots_type: lmots_sig.ots_type,
        nonce: lmots_sig.nonce,
        y: lmots_sig.y,
        path,
    };
    Ok(signature)
}

pub fn verify_lms_signature<const N: usize>(
    input_string: &[u8],
    lms_public_key: &LmsPublicKey<N>,
    lms_sig: &LmsSignature<N>,
) -> LMSResult<bool> {
    let (_, tree_height) = get_lms_parameters(&lms_sig.lms_type)?;
    let mut node_num = (1 << tree_height) + lms_sig.q;
    if node_num > 2 << tree_height {
        return Err("Invalid node number".to_string());
    }
    let lmots_signature = LmotsSignature {
        ots_type: lms_sig.ots_type,
        nonce: lms_sig.nonce,
        y: lms_sig.y.clone(),
    };
    let candidate_key = candidate_ots_signature(
        &lms_public_key.lms_identifier,
        &lms_sig.q.to_be_bytes(),
        &lmots_signature,
        input_string,
    )?;

    let mut hasher = Sha256::new();
    hasher.update(lms_public_key.lms_identifier);
    hasher.update(node_num.to_be_bytes());
    hasher.update(D_LEAF.to_be_bytes());
    hasher.update(candidate_key);
    let t_buf = hasher.finalize();
    let mut buf = [0u8; N];
    buf[..N].copy_from_slice(&t_buf[..N]);
    let mut temp = HashValue::<N>::from(buf);
    let mut i = 0;
    while node_num > 1 {
        if node_num % 2 == 1 {
            let mut hasher = Sha256::new();
            hasher.update(lms_public_key.lms_identifier);
            hasher.update((node_num / 2).to_be_bytes());
            hasher.update(D_INTR.to_be_bytes());
            hasher.update(lms_sig.path[i]);
            hasher.update(temp);
            let t_buf = hasher.finalize();
            let mut buf = [0u8; N];
            buf[..N].copy_from_slice(&t_buf[..N]);
            temp = HashValue::<N>::from(buf);
        } else {
            let mut hasher = Sha256::new();
            hasher.update(lms_public_key.lms_identifier);
            hasher.update((node_num / 2).to_be_bytes());
            hasher.update(D_INTR.to_be_bytes());
            hasher.update(temp);
            hasher.update(lms_sig.path[i]);
            let t_buf = hasher.finalize();
            let mut buf = [0u8; N];
            buf[..N].copy_from_slice(&t_buf[..N]);
            temp = HashValue::<N>::from(buf);
        }
        node_num /= 2;
        i += 1;
    }
    let candidate_key = temp;
    if candidate_key != lms_public_key.root_hash {
        return Ok(false);
    }

    Ok(true)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn lmots_params_test() {
        let result = get_lmots_parameters(&LmotsAlgorithmType::LmotsSha256N32W1).unwrap();
        assert_eq!(result.n, 32);
        assert_eq!(result.w, 1);
        assert_eq!(result.p, 265);
        assert_eq!(result.ls, 7);
        let result = get_lmots_parameters(&LmotsAlgorithmType::LmotsSha256N32W2).unwrap();
        assert_eq!(result.n, 32);
        assert_eq!(result.w, 2);
        assert_eq!(result.p, 133);
        assert_eq!(result.ls, 6);
        let result = get_lmots_parameters(&LmotsAlgorithmType::LmotsSha256N32W4).unwrap();
        assert_eq!(result.n, 32);
        assert_eq!(result.w, 4);
        assert_eq!(result.p, 67);
        assert_eq!(result.ls, 4);
        let result = get_lmots_parameters(&LmotsAlgorithmType::LmotsSha256N32W8).unwrap();
        assert_eq!(result.n, 32);
        assert_eq!(result.w, 8);
        assert_eq!(result.p, 34);
        assert_eq!(result.ls, 0);
        let result = get_lmots_parameters(&LmotsAlgorithmType::LmotsSha256N24W1).unwrap();
        assert_eq!(result.n, 24);
        assert_eq!(result.w, 1);
        assert_eq!(result.p, 200);
        assert_eq!(result.ls, 8);
        let result = get_lmots_parameters(&LmotsAlgorithmType::LmotsSha256N24W2).unwrap();
        assert_eq!(result.n, 24);
        assert_eq!(result.w, 2);
        assert_eq!(result.p, 101);
        assert_eq!(result.ls, 6);
        let result = get_lmots_parameters(&LmotsAlgorithmType::LmotsSha256N24W4).unwrap();
        assert_eq!(result.n, 24);
        assert_eq!(result.w, 4);
        assert_eq!(result.p, 51);
        assert_eq!(result.ls, 4);
        let result = get_lmots_parameters(&LmotsAlgorithmType::LmotsSha256N24W8).unwrap();
        assert_eq!(result.n, 24);
        assert_eq!(result.w, 8);
        assert_eq!(result.p, 26);
        assert_eq!(result.ls, 0);
    }

    // test case from https://datatracker.ietf.org/doc/html/rfc8554#section-3.1.3
    #[test]
    fn test_coefficient() {
        let input_value = [0x12u8, 0x34u8];
        let result = coefficient(&input_value, 7, 1).unwrap();
        assert_eq!(result, 0);

        let result = coefficient(&input_value, 0, 4).unwrap();
        assert_eq!(result, 1);
        // test out of bounds
        assert!(coefficient(&input_value, 20, 4).is_err());
        //test invalid w valid
        assert!(coefficient(&input_value, 0, 3).is_err());
    }

    #[test]
    fn test_get_lms_parameters() {
        let (n, h) = get_lms_parameters(&LmsAlgorithmType::LmsSha256N32H5).unwrap();
        assert_eq!(n, 32);
        assert_eq!(h, 5);
        let (n, h) = get_lms_parameters(&LmsAlgorithmType::LmsSha256N32H10).unwrap();
        assert_eq!(n, 32);
        assert_eq!(h, 10);
        let (n, h) = get_lms_parameters(&LmsAlgorithmType::LmsSha256N32H15).unwrap();
        assert_eq!(n, 32);
        assert_eq!(h, 15);
        let (n, h) = get_lms_parameters(&LmsAlgorithmType::LmsSha256N32H20).unwrap();
        assert_eq!(n, 32);
        assert_eq!(h, 20);
        let (n, h) = get_lms_parameters(&LmsAlgorithmType::LmsSha256N32H25).unwrap();
        assert_eq!(n, 32);
        assert_eq!(h, 25);
        let (n, h) = get_lms_parameters(&LmsAlgorithmType::LmsSha256N24H5).unwrap();
        assert_eq!(n, 24);
        assert_eq!(h, 5);
        let (n, h) = get_lms_parameters(&LmsAlgorithmType::LmsSha256N24H10).unwrap();
        assert_eq!(n, 24);
        assert_eq!(h, 10);
        let (n, h) = get_lms_parameters(&LmsAlgorithmType::LmsSha256N24H15).unwrap();
        assert_eq!(n, 24);
        assert_eq!(h, 15);
        let (n, h) = get_lms_parameters(&LmsAlgorithmType::LmsSha256N24H20).unwrap();
        assert_eq!(n, 24);
        assert_eq!(h, 20);
        let (n, h) = get_lms_parameters(&LmsAlgorithmType::LmsSha256N24H25).unwrap();
        assert_eq!(n, 24);
        assert_eq!(h, 25);
    }

    #[test]
    fn lookup_lms_alg_test() {
        for value in 5..15 as u32 {
            assert!(lookup_lms_algorithm_type(value).is_ok());
        }
        assert!(lookup_lms_algorithm_type(0).is_err());
        assert!(lookup_lms_algorithm_type(16).is_err());
    }

    #[test]
    fn lookup_lmots_alg_test() {
        for value in 1..9 as u32 {
            assert!(lookup_lmots_algorithm_type(value).is_ok());
        }
        assert!(lookup_lmots_algorithm_type(0).is_err());
        assert!(lookup_lmots_algorithm_type(9).is_err());
    }

    #[test]
    fn hss_upper() {
        let _levels = 2;
        //let lms_type = 5;
        //let lmots_type = 4;
        let identifier: LmsIdentifier = [
            0x61, 0xa5, 0xd5, 0x7d, 0x37, 0xf5, 0xe4, 0x6b, 0xfb, 0x75, 0x20, 0x80, 0x6b, 0x07,
            0xa1, 0xb8,
        ];
        let hss_public_key = Sha256Digest::from([
            0x50, 0x65, 0x0e, 0x3b, 0x31, 0xfe, 0x4a, 0x77, 0x3e, 0xa2, 0x9a, 0x07, 0xf0, 0x9c,
            0xf2, 0xea, 0x30, 0xe5, 0x79, 0xf0, 0xdf, 0x58, 0xef, 0x8e, 0x29, 0x8d, 0xa0, 0x43,
            0x4c, 0xb2, 0xb8, 0x78,
        ]);
        let _lower_public_hash: [u8; 32] = [
            0x6c, 0x50, 0x04, 0x91, 0x7d, 0xa6, 0xea, 0xfe, 0x4d, 0x9e, 0xf6, 0xc6, 0x40, 0x7b,
            0x3d, 0xb0, 0xe5, 0x48, 0x5b, 0x12, 0x2d, 0x9e, 0xbe, 0x15, 0xcd, 0xa9, 0x3c, 0xfe,
            0xc5, 0x82, 0xd7, 0xab,
        ];
        let _lower_public_identifier: LmsIdentifier = [
            0xd2, 0xf1, 0x4f, 0xf6, 0x34, 0x6a, 0xf9, 0x64, 0x56, 0x9f, 0x7d, 0x6c, 0xb8, 0x80,
            0xa1, 0xb6,
        ];

        // In HSS the upper level tree signs the concatenation of
        // lower_tree_lms_type, lower_tree_lmots_type, lower_tree_I, lower_tree_pubic_hash
        let public_buffer: [u8; 56] = [
            0, 0, 0, 5, // lms_type
            0, 0, 0, 4, //lmots_type
            0xd2, 0xf1, 0x4f, 0xf6, 0x34, 0x6a, 0xf9, 0x64, 0x56, 0x9f, 0x7d, 0x6c, 0xb8, 0x80,
            0xa1, 0xb6, // I, aka identifier
            //the hash
            0x6c, 0x50, 0x04, 0x91, 0x7d, 0xa6, 0xea, 0xfe, 0x4d, 0x9e, 0xf6, 0xc6, 0x40, 0x7b,
            0x3d, 0xb0, 0xe5, 0x48, 0x5b, 0x12, 0x2d, 0x9e, 0xbe, 0x15, 0xcd, 0xa9, 0x3c, 0xfe,
            0xc5, 0x82, 0xd7, 0xab,
        ];

        let q = 5;
        let upper_nonce: [u8; 32] = [
            0xd3, 0x2b, 0x56, 0x67, 0x1d, 0x7e, 0xb9, 0x88, 0x33, 0xc4, 0x9b, 0x43, 0x3c, 0x27,
            0x25, 0x86, 0xbc, 0x4a, 0x1c, 0x8a, 0x89, 0x70, 0x52, 0x8f, 0xfa, 0x04, 0xb9, 0x66,
            0xf9, 0x42, 0x6e, 0xb9,
        ];

        let y: [Sha256Digest; 34] = [
            Sha256Digest::from([
                0x96, 0x5a, 0x25, 0xbf, 0xd3, 0x7f, 0x19, 0x6b, 0x90, 0x73, 0xf3, 0xd4, 0xa2, 0x32,
                0xfe, 0xb6, 0x91, 0x28, 0xec, 0x45, 0x14, 0x6f, 0x86, 0x29, 0x2f, 0x9d, 0xff, 0x96,
                0x10, 0xa7, 0xbf, 0x95,
            ]),
            Sha256Digest::from([
                0xa6, 0x4c, 0x7f, 0x60, 0xf6, 0x26, 0x1a, 0x62, 0x04, 0x3f, 0x86, 0xc7, 0x03, 0x24,
                0xb7, 0x70, 0x7f, 0x5b, 0x4a, 0x8a, 0x6e, 0x19, 0xc1, 0x14, 0xc7, 0xbe, 0x86, 0x6d,
                0x48, 0x87, 0x78, 0xa0,
            ]),
            Sha256Digest::from([
                0xe0, 0x5f, 0xd5, 0xc6, 0x50, 0x9a, 0x6e, 0x61, 0xd5, 0x59, 0xcf, 0x1a, 0x77, 0xa9,
                0x70, 0xde, 0x92, 0x7d, 0x60, 0xc7, 0x0d, 0x3d, 0xe3, 0x1a, 0x7f, 0xa0, 0x10, 0x09,
                0x94, 0xe1, 0x62, 0xa2,
            ]),
            Sha256Digest::from([
                0x58, 0x2e, 0x8f, 0xf1, 0xb1, 0x0c, 0xd9, 0x9d, 0x4e, 0x8e, 0x41, 0x3e, 0xf4, 0x69,
                0x55, 0x9f, 0x7d, 0x7e, 0xd1, 0x2c, 0x83, 0x83, 0x42, 0xf9, 0xb9, 0xc9, 0x6b, 0x83,
                0xa4, 0x94, 0x3d, 0x16,
            ]),
            Sha256Digest::from([
                0x81, 0xd8, 0x4b, 0x15, 0x35, 0x7f, 0xf4, 0x8c, 0xa5, 0x79, 0xf1, 0x9f, 0x5e, 0x71,
                0xf1, 0x84, 0x66, 0xf2, 0xbb, 0xef, 0x4b, 0xf6, 0x60, 0xc2, 0x51, 0x8e, 0xb2, 0x0d,
                0xe2, 0xf6, 0x6e, 0x3b,
            ]),
            Sha256Digest::from([
                0x14, 0x78, 0x42, 0x69, 0xd7, 0xd8, 0x76, 0xf5, 0xd3, 0x5d, 0x3f, 0xbf, 0xc7, 0x03,
                0x9a, 0x46, 0x2c, 0x71, 0x6b, 0xb9, 0xf6, 0x89, 0x1a, 0x7f, 0x41, 0xad, 0x13, 0x3e,
                0x9e, 0x1f, 0x6d, 0x95,
            ]),
            Sha256Digest::from([
                0x60, 0xb9, 0x60, 0xe7, 0x77, 0x7c, 0x52, 0xf0, 0x60, 0x49, 0x2f, 0x2d, 0x7c, 0x66,
                0x0e, 0x14, 0x71, 0xe0, 0x7e, 0x72, 0x65, 0x55, 0x62, 0x03, 0x5a, 0xbc, 0x9a, 0x70,
                0x1b, 0x47, 0x3e, 0xcb,
            ]),
            Sha256Digest::from([
                0xc3, 0x94, 0x3c, 0x6b, 0x9c, 0x4f, 0x24, 0x05, 0xa3, 0xcb, 0x8b, 0xf8, 0xa6, 0x91,
                0xca, 0x51, 0xd3, 0xf6, 0xad, 0x2f, 0x42, 0x8b, 0xab, 0x6f, 0x3a, 0x30, 0xf5, 0x5d,
                0xd9, 0x62, 0x55, 0x63,
            ]),
            Sha256Digest::from([
                0xf0, 0xa7, 0x5e, 0xe3, 0x90, 0xe3, 0x85, 0xe3, 0xae, 0x0b, 0x90, 0x69, 0x61, 0xec,
                0xf4, 0x1a, 0xe0, 0x73, 0xa0, 0x59, 0x0c, 0x2e, 0xb6, 0x20, 0x4f, 0x44, 0x83, 0x1c,
                0x26, 0xdd, 0x76, 0x8c,
            ]),
            Sha256Digest::from([
                0x35, 0xb1, 0x67, 0xb2, 0x8c, 0xe8, 0xdc, 0x98, 0x8a, 0x37, 0x48, 0x25, 0x52, 0x30,
                0xce, 0xf9, 0x9e, 0xbf, 0x14, 0xe7, 0x30, 0x63, 0x2f, 0x27, 0x41, 0x44, 0x89, 0x80,
                0x8a, 0xfa, 0xb1, 0xd1,
            ]),
            Sha256Digest::from([
                0xe7, 0x83, 0xed, 0x04, 0x51, 0x6d, 0xe0, 0x12, 0x49, 0x86, 0x82, 0x21, 0x2b, 0x07,
                0x81, 0x05, 0x79, 0xb2, 0x50, 0x36, 0x59, 0x41, 0xbc, 0xc9, 0x81, 0x42, 0xda, 0x13,
                0x60, 0x9e, 0x97, 0x68,
            ]),
            Sha256Digest::from([
                0xaa, 0xf6, 0x5d, 0xe7, 0x62, 0x0d, 0xab, 0xec, 0x29, 0xeb, 0x82, 0xa1, 0x7f, 0xde,
                0x35, 0xaf, 0x15, 0xad, 0x23, 0x8c, 0x73, 0xf8, 0x1b, 0xdb, 0x8d, 0xec, 0x2f, 0xc0,
                0xe7, 0xf9, 0x32, 0x70,
            ]),
            Sha256Digest::from([
                0x10, 0x99, 0x76, 0x2b, 0x37, 0xf4, 0x3c, 0x4a, 0x3c, 0x20, 0x01, 0x0a, 0x3d, 0x72,
                0xe2, 0xf6, 0x06, 0xbe, 0x10, 0x8d, 0x31, 0x0e, 0x63, 0x9f, 0x09, 0xce, 0x72, 0x86,
                0x80, 0x0d, 0x9e, 0xf8,
            ]),
            Sha256Digest::from([
                0xa1, 0xa4, 0x02, 0x81, 0xcc, 0x5a, 0x7e, 0xa9, 0x8d, 0x2a, 0xdc, 0x7c, 0x74, 0x00,
                0xc2, 0xfe, 0x5a, 0x10, 0x15, 0x52, 0xdf, 0x4e, 0x3c, 0xcc, 0xfd, 0x0c, 0xbf, 0x2d,
                0xdf, 0x5d, 0xc6, 0x77,
            ]),
            Sha256Digest::from([
                0x9c, 0xbb, 0xc6, 0x8f, 0xee, 0x0c, 0x3e, 0xfe, 0x4e, 0xc2, 0x2b, 0x83, 0xa2, 0xca,
                0xa3, 0xe4, 0x8e, 0x08, 0x09, 0xa0, 0xa7, 0x50, 0xb7, 0x3c, 0xcd, 0xcf, 0x3c, 0x79,
                0xe6, 0x58, 0x0c, 0x15,
            ]),
            Sha256Digest::from([
                0x4f, 0x8a, 0x58, 0xf7, 0xf2, 0x43, 0x35, 0xee, 0xc5, 0xc5, 0xeb, 0x5e, 0x0c, 0xf0,
                0x1d, 0xcf, 0x44, 0x39, 0x42, 0x40, 0x95, 0xfc, 0xeb, 0x07, 0x7f, 0x66, 0xde, 0xd5,
                0xbe, 0xc7, 0x3b, 0x27,
            ]),
            Sha256Digest::from([
                0xc5, 0xb9, 0xf6, 0x4a, 0x2a, 0x9a, 0xf2, 0xf0, 0x7c, 0x05, 0xe9, 0x9e, 0x5c, 0xf8,
                0x0f, 0x00, 0x25, 0x2e, 0x39, 0xdb, 0x32, 0xf6, 0xc1, 0x96, 0x74, 0xf1, 0x90, 0xc9,
                0xfb, 0xc5, 0x06, 0xd8,
            ]),
            Sha256Digest::from([
                0x26, 0x85, 0x77, 0x13, 0xaf, 0xd2, 0xca, 0x6b, 0xb8, 0x5c, 0xd8, 0xc1, 0x07, 0x34,
                0x75, 0x52, 0xf3, 0x05, 0x75, 0xa5, 0x41, 0x78, 0x16, 0xab, 0x4d, 0xb3, 0xf6, 0x03,
                0xf2, 0xdf, 0x56, 0xfb,
            ]),
            Sha256Digest::from([
                0xc4, 0x13, 0xe7, 0xd0, 0xac, 0xd8, 0xbd, 0xd8, 0x13, 0x52, 0xb2, 0x47, 0x1f, 0xc1,
                0xbc, 0x4f, 0x1e, 0xf2, 0x96, 0xfe, 0xa1, 0x22, 0x04, 0x03, 0x46, 0x6b, 0x1a, 0xfe,
                0x78, 0xb9, 0x4f, 0x7e,
            ]),
            Sha256Digest::from([
                0xcf, 0x7c, 0xc6, 0x2f, 0xb9, 0x2b, 0xe1, 0x4f, 0x18, 0xc2, 0x19, 0x23, 0x84, 0xeb,
                0xce, 0xaf, 0x88, 0x01, 0xaf, 0xdf, 0x94, 0x7f, 0x69, 0x8c, 0xe9, 0xc6, 0xce, 0xb6,
                0x96, 0xed, 0x70, 0xe9,
            ]),
            Sha256Digest::from([
                0xe8, 0x7b, 0x01, 0x44, 0x41, 0x7e, 0x8d, 0x7b, 0xaf, 0x25, 0xeb, 0x5f, 0x70, 0xf0,
                0x9f, 0x01, 0x6f, 0xc9, 0x25, 0xb4, 0xdb, 0x04, 0x8a, 0xb8, 0xd8, 0xcb, 0x2a, 0x66,
                0x1c, 0xe3, 0xb5, 0x7a,
            ]),
            Sha256Digest::from([
                0xda, 0x67, 0x57, 0x1f, 0x5d, 0xd5, 0x46, 0xfc, 0x22, 0xcb, 0x1f, 0x97, 0xe0, 0xeb,
                0xd1, 0xa6, 0x59, 0x26, 0xb1, 0x23, 0x4f, 0xd0, 0x4f, 0x17, 0x1c, 0xf4, 0x69, 0xc7,
                0x6b, 0x88, 0x4c, 0xf3,
            ]),
            Sha256Digest::from([
                0x11, 0x5c, 0xce, 0x6f, 0x79, 0x2c, 0xc8, 0x4e, 0x36, 0xda, 0x58, 0x96, 0x0c, 0x5f,
                0x1d, 0x76, 0x0f, 0x32, 0xc1, 0x2f, 0xae, 0xf4, 0x77, 0xe9, 0x4c, 0x92, 0xeb, 0x75,
                0x62, 0x5b, 0x6a, 0x37,
            ]),
            Sha256Digest::from([
                0x1e, 0xfc, 0x72, 0xd6, 0x0c, 0xa5, 0xe9, 0x08, 0xb3, 0xa7, 0xdd, 0x69, 0xfe, 0xf0,
                0x24, 0x91, 0x50, 0xe3, 0xee, 0xbd, 0xfe, 0xd3, 0x9c, 0xbd, 0xc3, 0xce, 0x97, 0x04,
                0x88, 0x2a, 0x20, 0x72,
            ]),
            Sha256Digest::from([
                0xc7, 0x5e, 0x13, 0x52, 0x7b, 0x7a, 0x58, 0x1a, 0x55, 0x61, 0x68, 0x78, 0x3d, 0xc1,
                0xe9, 0x75, 0x45, 0xe3, 0x18, 0x65, 0xdd, 0xc4, 0x6b, 0x3c, 0x95, 0x78, 0x35, 0xda,
                0x25, 0x2b, 0xb7, 0x32,
            ]),
            Sha256Digest::from([
                0x8d, 0x3e, 0xe2, 0x06, 0x24, 0x45, 0xdf, 0xb8, 0x5e, 0xf8, 0xc3, 0x5f, 0x8e, 0x1f,
                0x33, 0x71, 0xaf, 0x34, 0x02, 0x3c, 0xef, 0x62, 0x6e, 0x0a, 0xf1, 0xe0, 0xbc, 0x01,
                0x73, 0x51, 0xaa, 0xe2,
            ]),
            Sha256Digest::from([
                0xab, 0x8f, 0x5c, 0x61, 0x2e, 0xad, 0x0b, 0x72, 0x9a, 0x1d, 0x05, 0x9d, 0x02, 0xbf,
                0xe1, 0x8e, 0xfa, 0x97, 0x1b, 0x73, 0x00, 0xe8, 0x82, 0x36, 0x0a, 0x93, 0xb0, 0x25,
                0xff, 0x97, 0xe9, 0xe0,
            ]),
            Sha256Digest::from([
                0xee, 0xc0, 0xf3, 0xf3, 0xf1, 0x30, 0x39, 0xa1, 0x7f, 0x88, 0xb0, 0xcf, 0x80, 0x8f,
                0x48, 0x84, 0x31, 0x60, 0x6c, 0xb1, 0x3f, 0x92, 0x41, 0xf4, 0x0f, 0x44, 0xe5, 0x37,
                0xd3, 0x02, 0xc6, 0x4a,
            ]),
            Sha256Digest::from([
                0x4f, 0x1f, 0x4a, 0xb9, 0x49, 0xb9, 0xfe, 0xef, 0xad, 0xcb, 0x71, 0xab, 0x50, 0xef,
                0x27, 0xd6, 0xd6, 0xca, 0x85, 0x10, 0xf1, 0x50, 0xc8, 0x5f, 0xb5, 0x25, 0xbf, 0x25,
                0x70, 0x3d, 0xf7, 0x20,
            ]),
            Sha256Digest::from([
                0x9b, 0x60, 0x66, 0xf0, 0x9c, 0x37, 0x28, 0x0d, 0x59, 0x12, 0x8d, 0x2f, 0x0f, 0x63,
                0x7c, 0x7d, 0x7d, 0x7f, 0xad, 0x4e, 0xd1, 0xc1, 0xea, 0x04, 0xe6, 0x28, 0xd2, 0x21,
                0xe3, 0xd8, 0xdb, 0x77,
            ]),
            Sha256Digest::from([
                0xb7, 0xc8, 0x78, 0xc9, 0x41, 0x1c, 0xaf, 0xc5, 0x07, 0x1a, 0x34, 0xa0, 0x0f, 0x4c,
                0xf0, 0x77, 0x38, 0x91, 0x27, 0x53, 0xdf, 0xce, 0x48, 0xf0, 0x75, 0x76, 0xf0, 0xd4,
                0xf9, 0x4f, 0x42, 0xc6,
            ]),
            Sha256Digest::from([
                0xd7, 0x6f, 0x7c, 0xe9, 0x73, 0xe9, 0x36, 0x70, 0x95, 0xba, 0x7e, 0x9a, 0x36, 0x49,
                0xb7, 0xf4, 0x61, 0xd9, 0xf9, 0xac, 0x13, 0x32, 0xa4, 0xd1, 0x04, 0x4c, 0x96, 0xae,
                0xfe, 0xe6, 0x76, 0x76,
            ]),
            Sha256Digest::from([
                0x40, 0x1b, 0x64, 0x45, 0x7c, 0x54, 0xd6, 0x5f, 0xef, 0x65, 0x00, 0xc5, 0x9c, 0xdf,
                0xb6, 0x9a, 0xf7, 0xb6, 0xdd, 0xdf, 0xcb, 0x0f, 0x08, 0x62, 0x78, 0xdd, 0x8a, 0xd0,
                0x68, 0x60, 0x78, 0xdf,
            ]),
            Sha256Digest::from([
                0xb0, 0xf3, 0xf7, 0x9c, 0xd8, 0x93, 0xd3, 0x14, 0x16, 0x86, 0x48, 0x49, 0x98, 0x98,
                0xfb, 0xc0, 0xce, 0xd5, 0xf9, 0x5b, 0x74, 0xe8, 0xff, 0x14, 0xd7, 0x35, 0xcd, 0xea,
                0x96, 0x8b, 0xee, 0x74,
            ]),
        ];
        let path: [Sha256Digest; 5] = [
            Sha256Digest::from([
                0xd8, 0xb8, 0x11, 0x2f, 0x92, 0x00, 0xa5, 0xe5, 0x0c, 0x4a, 0x26, 0x21, 0x65, 0xbd,
                0x34, 0x2c, 0xd8, 0x00, 0xb8, 0x49, 0x68, 0x10, 0xbc, 0x71, 0x62, 0x77, 0x43, 0x5a,
                0xc3, 0x76, 0x72, 0x8d,
            ]),
            Sha256Digest::from([
                0x12, 0x9a, 0xc6, 0xed, 0xa8, 0x39, 0xa6, 0xf3, 0x57, 0xb5, 0xa0, 0x43, 0x87, 0xc5,
                0xce, 0x97, 0x38, 0x2a, 0x78, 0xf2, 0xa4, 0x37, 0x29, 0x17, 0xee, 0xfc, 0xbf, 0x93,
                0xf6, 0x3b, 0xb5, 0x91,
            ]),
            Sha256Digest::from([
                0x12, 0xf5, 0xdb, 0xe4, 0x00, 0xbd, 0x49, 0xe4, 0x50, 0x1e, 0x85, 0x9f, 0x88, 0x5b,
                0xf0, 0x73, 0x6e, 0x90, 0xa5, 0x09, 0xb3, 0x0a, 0x26, 0xbf, 0xac, 0x8c, 0x17, 0xb5,
                0x99, 0x1c, 0x15, 0x7e,
            ]),
            Sha256Digest::from([
                0xb5, 0x97, 0x11, 0x15, 0xaa, 0x39, 0xef, 0xd8, 0xd5, 0x64, 0xa6, 0xb9, 0x02, 0x82,
                0xc3, 0x16, 0x8a, 0xf2, 0xd3, 0x0e, 0xf8, 0x9d, 0x51, 0xbf, 0x14, 0x65, 0x45, 0x10,
                0xa1, 0x2b, 0x8a, 0x14,
            ]),
            Sha256Digest::from([
                0x4c, 0xca, 0x18, 0x48, 0xcf, 0x7d, 0xa5, 0x9c, 0xc2, 0xb3, 0xd9, 0xd0, 0x69, 0x2d,
                0xd2, 0xa2, 0x0b, 0xa3, 0x86, 0x34, 0x80, 0xe2, 0x5b, 0x1b, 0x85, 0xee, 0x86, 0x0c,
                0x62, 0xbf, 0x51, 0x36,
            ]),
        ];

        let upper_ots = LmotsSignature {
            ots_type: LmotsAlgorithmType::LmotsSha256N32W8,
            nonce: upper_nonce,
            y: y.to_vec(),
        };

        let upper_signature = LmsSignature {
            q,
            ots_type: upper_ots.ots_type,
            nonce: upper_ots.nonce,
            y: upper_ots.y,
            lms_type: LmsAlgorithmType::LmsSha256N32H5,
            path: Vec::from(path),
        };
        let lms_public_key = LmsPublicKey {
            lms_identifier: identifier,
            root_hash: hss_public_key,
            lms_type: LmsAlgorithmType::LmsSha256N32H5,
            lmots_type: LmotsAlgorithmType::LmotsSha256N32W8,
        };

        let success =
            verify_lms_signature(&public_buffer, &lms_public_key, &upper_signature).unwrap();
        assert!(success);
    }

    #[test]
    fn lms_lower() {
        let message: [u8; 162] = [
            0x54, 0x68, 0x65, 0x20, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x73, 0x20, 0x6e, 0x6f, 0x74,
            0x20, 0x64, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,
            0x74, 0x68, 0x65, 0x20, 0x55, 0x6e, 0x69, 0x74, 0x65, 0x64, 0x20, 0x53, 0x74, 0x61,
            0x74, 0x65, 0x73, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e,
            0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x6e, 0x6f, 0x72,
            0x20, 0x70, 0x72, 0x6f, 0x68, 0x69, 0x62, 0x69, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79,
            0x20, 0x69, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x74, 0x61,
            0x74, 0x65, 0x73, 0x2c, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72,
            0x76, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x74, 0x61,
            0x74, 0x65, 0x73, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65,
            0x6c, 0x79, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
            0x70, 0x65, 0x6f, 0x70, 0x6c, 0x65, 0x2e, 0x0a,
        ];
        let lms_public_identifier: LmsIdentifier = [
            0xd2, 0xf1, 0x4f, 0xf6, 0x34, 0x6a, 0xf9, 0x64, 0x56, 0x9f, 0x7d, 0x6c, 0xb8, 0x80,
            0xa1, 0xb6,
        ];

        let lms_public_key = Sha256Digest::from([
            0x6c, 0x50, 0x04, 0x91, 0x7d, 0xa6, 0xea, 0xfe, 0x4d, 0x9e, 0xf6, 0xc6, 0x40, 0x7b,
            0x3d, 0xb0, 0xe5, 0x48, 0x5b, 0x12, 0x2d, 0x9e, 0xbe, 0x15, 0xcd, 0xa9, 0x3c, 0xfe,
            0xc5, 0x82, 0xd7, 0xab,
        ]);

        // final signature
        let lms_q = 0xa;
        let final_c: [u8; 32] = [
            0x07, 0x03, 0xc4, 0x91, 0xe7, 0x55, 0x8b, 0x35, 0x01, 0x1e, 0xce, 0x35, 0x92, 0xea,
            0xa5, 0xda, 0x4d, 0x91, 0x87, 0x86, 0x77, 0x12, 0x33, 0xe8, 0x35, 0x3b, 0xc4, 0xf6,
            0x23, 0x23, 0x18, 0x5c,
        ];
        let final_y: [Sha256Digest; 34] = [
            Sha256Digest::from([
                0x95, 0xca, 0xe0, 0x5b, 0x89, 0x9e, 0x35, 0xdf, 0xfd, 0x71, 0x70, 0x54, 0x70, 0x62,
                0x09, 0x98, 0x8e, 0xbf, 0xdf, 0x6e, 0x37, 0x96, 0x0b, 0xb5, 0xc3, 0x8d, 0x76, 0x57,
                0xe8, 0xbf, 0xfe, 0xef,
            ]),
            Sha256Digest::from([
                0x9b, 0xc0, 0x42, 0xda, 0x4b, 0x45, 0x25, 0x65, 0x04, 0x85, 0xc6, 0x6d, 0x0c, 0xe1,
                0x9b, 0x31, 0x75, 0x87, 0xc6, 0xba, 0x4b, 0xff, 0xcc, 0x42, 0x8e, 0x25, 0xd0, 0x89,
                0x31, 0xe7, 0x2d, 0xfb,
            ]),
            Sha256Digest::from([
                0x6a, 0x12, 0x0c, 0x56, 0x12, 0x34, 0x42, 0x58, 0xb8, 0x5e, 0xfd, 0xb7, 0xdb, 0x1d,
                0xb9, 0xe1, 0x86, 0x5a, 0x73, 0xca, 0xf9, 0x65, 0x57, 0xeb, 0x39, 0xed, 0x3e, 0x3f,
                0x42, 0x69, 0x33, 0xac,
            ]),
            Sha256Digest::from([
                0x9e, 0xed, 0xdb, 0x03, 0xa1, 0xd2, 0x37, 0x4a, 0xf7, 0xbf, 0x77, 0x18, 0x55, 0x77,
                0x45, 0x62, 0x37, 0xf9, 0xde, 0x2d, 0x60, 0x11, 0x3c, 0x23, 0xf8, 0x46, 0xdf, 0x26,
                0xfa, 0x94, 0x20, 0x08,
            ]),
            Sha256Digest::from([
                0xa6, 0x98, 0x99, 0x4c, 0x08, 0x27, 0xd9, 0x0e, 0x86, 0xd4, 0x3e, 0x0d, 0xf7, 0xf4,
                0xbf, 0xcd, 0xb0, 0x9b, 0x86, 0xa3, 0x73, 0xb9, 0x82, 0x88, 0xb7, 0x09, 0x4a, 0xd8,
                0x1a, 0x01, 0x85, 0xac,
            ]),
            Sha256Digest::from([
                0x10, 0x0e, 0x4f, 0x2c, 0x5f, 0xc3, 0x8c, 0x00, 0x3c, 0x1a, 0xb6, 0xfe, 0xa4, 0x79,
                0xeb, 0x2f, 0x5e, 0xbe, 0x48, 0xf5, 0x84, 0xd7, 0x15, 0x9b, 0x8a, 0xda, 0x03, 0x58,
                0x6e, 0x65, 0xad, 0x9c,
            ]),
            Sha256Digest::from([
                0x96, 0x9f, 0x6a, 0xec, 0xbf, 0xe4, 0x4c, 0xf3, 0x56, 0x88, 0x8a, 0x7b, 0x15, 0xa3,
                0xff, 0x07, 0x4f, 0x77, 0x17, 0x60, 0xb2, 0x6f, 0x9c, 0x04, 0x88, 0x4e, 0xe1, 0xfa,
                0xa3, 0x29, 0xfb, 0xf4,
            ]),
            Sha256Digest::from([
                0xe6, 0x1a, 0xf2, 0x3a, 0xee, 0x7f, 0xa5, 0xd4, 0xd9, 0xa5, 0xdf, 0xcf, 0x43, 0xc4,
                0xc2, 0x6c, 0xe8, 0xae, 0xa2, 0xce, 0x8a, 0x29, 0x90, 0xd7, 0xba, 0x7b, 0x57, 0x10,
                0x8b, 0x47, 0xda, 0xbf,
            ]),
            Sha256Digest::from([
                0xbe, 0xad, 0xb2, 0xb2, 0x5b, 0x3c, 0xac, 0xc1, 0xac, 0x0c, 0xef, 0x34, 0x6c, 0xbb,
                0x90, 0xfb, 0x04, 0x4b, 0xee, 0xe4, 0xfa, 0xc2, 0x60, 0x3a, 0x44, 0x2b, 0xdf, 0x7e,
                0x50, 0x72, 0x43, 0xb7,
            ]),
            Sha256Digest::from([
                0x31, 0x9c, 0x99, 0x44, 0xb1, 0x58, 0x6e, 0x89, 0x9d, 0x43, 0x1c, 0x7f, 0x91, 0xbc,
                0xcc, 0xc8, 0x69, 0x0d, 0xbf, 0x59, 0xb2, 0x83, 0x86, 0xb2, 0x31, 0x5f, 0x3d, 0x36,
                0xef, 0x2e, 0xaa, 0x3c,
            ]),
            Sha256Digest::from([
                0xf3, 0x0b, 0x2b, 0x51, 0xf4, 0x8b, 0x71, 0xb0, 0x03, 0xdf, 0xb0, 0x82, 0x49, 0x48,
                0x42, 0x01, 0x04, 0x3f, 0x65, 0xf5, 0xa3, 0xef, 0x6b, 0xbd, 0x61, 0xdd, 0xfe, 0xe8,
                0x1a, 0xca, 0x9c, 0xe6,
            ]),
            Sha256Digest::from([
                0x00, 0x81, 0x26, 0x2a, 0x00, 0x00, 0x04, 0x80, 0xdc, 0xbc, 0x9a, 0x3d, 0xa6, 0xfb,
                0xef, 0x5c, 0x1c, 0x0a, 0x55, 0xe4, 0x8a, 0x0e, 0x72, 0x9f, 0x91, 0x84, 0xfc, 0xb1,
                0x40, 0x7c, 0x31, 0x52,
            ]),
            Sha256Digest::from([
                0x9d, 0xb2, 0x68, 0xf6, 0xfe, 0x50, 0x03, 0x2a, 0x36, 0x3c, 0x98, 0x01, 0x30, 0x68,
                0x37, 0xfa, 0xfa, 0xbd, 0xf9, 0x57, 0xfd, 0x97, 0xea, 0xfc, 0x80, 0xdb, 0xd1, 0x65,
                0xe4, 0x35, 0xd0, 0xe2,
            ]),
            Sha256Digest::from([
                0xdf, 0xd8, 0x36, 0xa2, 0x8b, 0x35, 0x40, 0x23, 0x92, 0x4b, 0x6f, 0xb7, 0xe4, 0x8b,
                0xc0, 0xb3, 0xed, 0x95, 0xee, 0xa6, 0x4c, 0x2d, 0x40, 0x2f, 0x4d, 0x73, 0x4c, 0x8d,
                0xc2, 0x6f, 0x3a, 0xc5,
            ]),
            Sha256Digest::from([
                0x91, 0x82, 0x5d, 0xae, 0xf0, 0x1e, 0xae, 0x3c, 0x38, 0xe3, 0x32, 0x8d, 0x00, 0xa7,
                0x7d, 0xc6, 0x57, 0x03, 0x4f, 0x28, 0x7c, 0xcb, 0x0f, 0x0e, 0x1c, 0x9a, 0x7c, 0xbd,
                0xc8, 0x28, 0xf6, 0x27,
            ]),
            Sha256Digest::from([
                0x20, 0x5e, 0x47, 0x37, 0xb8, 0x4b, 0x58, 0x37, 0x65, 0x51, 0xd4, 0x4c, 0x12, 0xc3,
                0xc2, 0x15, 0xc8, 0x12, 0xa0, 0x97, 0x07, 0x89, 0xc8, 0x3d, 0xe5, 0x1d, 0x6a, 0xd7,
                0x87, 0x27, 0x19, 0x63,
            ]),
            Sha256Digest::from([
                0x32, 0x7f, 0x0a, 0x5f, 0xbb, 0x6b, 0x59, 0x07, 0xde, 0xc0, 0x2c, 0x9a, 0x90, 0x93,
                0x4a, 0xf5, 0xa1, 0xc6, 0x3b, 0x72, 0xc8, 0x26, 0x53, 0x60, 0x5d, 0x1d, 0xcc, 0xe5,
                0x15, 0x96, 0xb3, 0xc2,
            ]),
            Sha256Digest::from([
                0xb4, 0x56, 0x96, 0x68, 0x9f, 0x2e, 0xb3, 0x82, 0x00, 0x74, 0x97, 0x55, 0x76, 0x92,
                0xca, 0xac, 0x4d, 0x57, 0xb5, 0xde, 0x9f, 0x55, 0x69, 0xbc, 0x2a, 0xd0, 0x13, 0x7f,
                0xd4, 0x7f, 0xb4, 0x7e,
            ]),
            Sha256Digest::from([
                0x66, 0x4f, 0xcb, 0x6d, 0xb4, 0x97, 0x1f, 0x5b, 0x3e, 0x07, 0xac, 0xed, 0xa9, 0xac,
                0x13, 0x0e, 0x9f, 0x38, 0x18, 0x2d, 0xe9, 0x94, 0xcf, 0xf1, 0x92, 0xec, 0x0e, 0x82,
                0xfd, 0x6d, 0x4c, 0xb7,
            ]),
            Sha256Digest::from([
                0xf3, 0xfe, 0x00, 0x81, 0x25, 0x89, 0xb7, 0xa7, 0xce, 0x51, 0x54, 0x40, 0x45, 0x64,
                0x33, 0x01, 0x6b, 0x84, 0xa5, 0x9b, 0xec, 0x66, 0x19, 0xa1, 0xc6, 0xc0, 0xb3, 0x7d,
                0xd1, 0x45, 0x0e, 0xd4,
            ]),
            Sha256Digest::from([
                0xf2, 0xd8, 0xb5, 0x84, 0x41, 0x0c, 0xed, 0xa8, 0x02, 0x5f, 0x5d, 0x2d, 0x8d, 0xd0,
                0xd2, 0x17, 0x6f, 0xc1, 0xcf, 0x2c, 0xc0, 0x6f, 0xa8, 0xc8, 0x2b, 0xed, 0x4d, 0x94,
                0x4e, 0x71, 0x33, 0x9e,
            ]),
            Sha256Digest::from([
                0xce, 0x78, 0x0f, 0xd0, 0x25, 0xbd, 0x41, 0xec, 0x34, 0xeb, 0xff, 0x9d, 0x42, 0x70,
                0xa3, 0x22, 0x4e, 0x01, 0x9f, 0xcb, 0x44, 0x44, 0x74, 0xd4, 0x82, 0xfd, 0x2d, 0xbe,
                0x75, 0xef, 0xb2, 0x03,
            ]),
            Sha256Digest::from([
                0x89, 0xcc, 0x10, 0xcd, 0x60, 0x0a, 0xbb, 0x54, 0xc4, 0x7e, 0xde, 0x93, 0xe0, 0x8c,
                0x11, 0x4e, 0xdb, 0x04, 0x11, 0x7d, 0x71, 0x4d, 0xc1, 0xd5, 0x25, 0xe1, 0x1b, 0xed,
                0x87, 0x56, 0x19, 0x2f,
            ]),
            Sha256Digest::from([
                0x92, 0x9d, 0x15, 0x46, 0x2b, 0x93, 0x9f, 0xf3, 0xf5, 0x2f, 0x22, 0x52, 0xda, 0x2e,
                0xd6, 0x4d, 0x8f, 0xae, 0x88, 0x81, 0x8b, 0x1e, 0xfa, 0x2c, 0x7b, 0x08, 0xc8, 0x79,
                0x4f, 0xb1, 0xb2, 0x14,
            ]),
            Sha256Digest::from([
                0xaa, 0x23, 0x3d, 0xb3, 0x16, 0x28, 0x33, 0x14, 0x1e, 0xa4, 0x38, 0x3f, 0x1a, 0x6f,
                0x12, 0x0b, 0xe1, 0xdb, 0x82, 0xce, 0x36, 0x30, 0xb3, 0x42, 0x91, 0x14, 0x46, 0x31,
                0x57, 0xa6, 0x4e, 0x91,
            ]),
            Sha256Digest::from([
                0x23, 0x4d, 0x47, 0x5e, 0x2f, 0x79, 0xcb, 0xf0, 0x5e, 0x4d, 0xb6, 0xa9, 0x40, 0x7d,
                0x72, 0xc6, 0xbf, 0xf7, 0xd1, 0x19, 0x8b, 0x5c, 0x4d, 0x6a, 0xad, 0x28, 0x31, 0xdb,
                0x61, 0x27, 0x49, 0x93,
            ]),
            Sha256Digest::from([
                0x71, 0x5a, 0x01, 0x82, 0xc7, 0xdc, 0x80, 0x89, 0xe3, 0x2c, 0x85, 0x31, 0xde, 0xed,
                0x4f, 0x74, 0x31, 0xc0, 0x7c, 0x02, 0x19, 0x5e, 0xba, 0x2e, 0xf9, 0x1e, 0xfb, 0x56,
                0x13, 0xc3, 0x7a, 0xf7,
            ]),
            Sha256Digest::from([
                0xae, 0x0c, 0x06, 0x6b, 0xab, 0xc6, 0x93, 0x69, 0x70, 0x0e, 0x1d, 0xd2, 0x6e, 0xdd,
                0xc0, 0xd2, 0x16, 0xc7, 0x81, 0xd5, 0x6e, 0x4c, 0xe4, 0x7e, 0x33, 0x03, 0xfa, 0x73,
                0x00, 0x7f, 0xf7, 0xb9,
            ]),
            Sha256Digest::from([
                0x49, 0xef, 0x23, 0xbe, 0x2a, 0xa4, 0xdb, 0xf2, 0x52, 0x06, 0xfe, 0x45, 0xc2, 0x0d,
                0xd8, 0x88, 0x39, 0x5b, 0x25, 0x26, 0x39, 0x1a, 0x72, 0x49, 0x96, 0xa4, 0x41, 0x56,
                0xbe, 0xac, 0x80, 0x82,
            ]),
            Sha256Digest::from([
                0x12, 0x85, 0x87, 0x92, 0xbf, 0x8e, 0x74, 0xcb, 0xa4, 0x9d, 0xee, 0x5e, 0x88, 0x12,
                0xe0, 0x19, 0xda, 0x87, 0x45, 0x4b, 0xff, 0x9e, 0x84, 0x7e, 0xd8, 0x3d, 0xb0, 0x7a,
                0xf3, 0x13, 0x74, 0x30,
            ]),
            Sha256Digest::from([
                0x82, 0xf8, 0x80, 0xa2, 0x78, 0xf6, 0x82, 0xc2, 0xbd, 0x0a, 0xd6, 0x88, 0x7c, 0xb5,
                0x9f, 0x65, 0x2e, 0x15, 0x59, 0x87, 0xd6, 0x1b, 0xbf, 0x6a, 0x88, 0xd3, 0x6e, 0xe9,
                0x3b, 0x60, 0x72, 0xe6,
            ]),
            Sha256Digest::from([
                0x65, 0x6d, 0x9c, 0xcb, 0xaa, 0xe3, 0xd6, 0x55, 0x85, 0x2e, 0x38, 0xde, 0xb3, 0xa2,
                0xdc, 0xf8, 0x05, 0x8d, 0xc9, 0xfb, 0x6f, 0x2a, 0xb3, 0xd3, 0xb3, 0x53, 0x9e, 0xb7,
                0x7b, 0x24, 0x8a, 0x66,
            ]),
            Sha256Digest::from([
                0x10, 0x91, 0xd0, 0x5e, 0xb6, 0xe2, 0xf2, 0x97, 0x77, 0x4f, 0xe6, 0x05, 0x35, 0x98,
                0x45, 0x7c, 0xc6, 0x19, 0x08, 0x31, 0x8d, 0xe4, 0xb8, 0x26, 0xf0, 0xfc, 0x86, 0xd4,
                0xbb, 0x11, 0x7d, 0x33,
            ]),
            Sha256Digest::from([
                0xe8, 0x65, 0xaa, 0x80, 0x50, 0x09, 0xcc, 0x29, 0x18, 0xd9, 0xc2, 0xf8, 0x40, 0xc4,
                0xda, 0x43, 0xa7, 0x03, 0xad, 0x9f, 0x5b, 0x58, 0x06, 0x16, 0x3d, 0x71, 0x61, 0x69,
                0x6b, 0x5a, 0x0a, 0xdc,
            ]),
        ];

        let final_path: [Sha256Digest; 5] = [
            Sha256Digest::from([
                0xd5, 0xc0, 0xd1, 0xbe, 0xbb, 0x06, 0x04, 0x8e, 0xd6, 0xfe, 0x2e, 0xf2, 0xc6, 0xce,
                0xf3, 0x05, 0xb3, 0xed, 0x63, 0x39, 0x41, 0xeb, 0xc8, 0xb3, 0xbe, 0xc9, 0x73, 0x87,
                0x54, 0xcd, 0xdd, 0x60,
            ]),
            Sha256Digest::from([
                0xe1, 0x92, 0x0a, 0xda, 0x52, 0xf4, 0x3d, 0x05, 0x5b, 0x50, 0x31, 0xce, 0xe6, 0x19,
                0x25, 0x20, 0xd6, 0xa5, 0x11, 0x55, 0x14, 0x85, 0x1c, 0xe7, 0xfd, 0x44, 0x8d, 0x4a,
                0x39, 0xfa, 0xe2, 0xab,
            ]),
            Sha256Digest::from([
                0x23, 0x35, 0xb5, 0x25, 0xf4, 0x84, 0xe9, 0xb4, 0x0d, 0x6a, 0x4a, 0x96, 0x93, 0x94,
                0x84, 0x3b, 0xdc, 0xf6, 0xd1, 0x4c, 0x48, 0xe8, 0x01, 0x5e, 0x08, 0xab, 0x92, 0x66,
                0x2c, 0x05, 0xc6, 0xe9,
            ]),
            Sha256Digest::from([
                0xf9, 0x0b, 0x65, 0xa7, 0xa6, 0x20, 0x16, 0x89, 0x99, 0x9f, 0x32, 0xbf, 0xd3, 0x68,
                0xe5, 0xe3, 0xec, 0x9c, 0xb7, 0x0a, 0xc7, 0xb8, 0x39, 0x90, 0x03, 0xf1, 0x75, 0xc4,
                0x08, 0x85, 0x08, 0x1a,
            ]),
            Sha256Digest::from([
                0x09, 0xab, 0x30, 0x34, 0x91, 0x1f, 0xe1, 0x25, 0x63, 0x10, 0x51, 0xdf, 0x04, 0x08,
                0xb3, 0x94, 0x6b, 0x0b, 0xde, 0x79, 0x09, 0x11, 0xe8, 0x97, 0x8b, 0xa0, 0x7d, 0xd5,
                0x6c, 0x73, 0xe7, 0xee,
            ]),
        ];

        let final_ots_sig = LmotsSignature {
            ots_type: LmotsAlgorithmType::LmotsSha256N32W8,
            nonce: final_c,
            y: final_y.to_vec(),
        };

        let final_lms_sig = LmsSignature {
            q: lms_q,
            ots_type: final_ots_sig.ots_type,
            nonce: final_ots_sig.nonce,
            y: final_ots_sig.y,
            lms_type: LmsAlgorithmType::LmsSha256N32H5,
            path: Vec::from(final_path),
        };

        let lms_public_key = LmsPublicKey {
            lms_identifier: lms_public_identifier,
            root_hash: lms_public_key,
            lms_type: LmsAlgorithmType::LmsSha256N32H5,
            lmots_type: LmotsAlgorithmType::LmotsSha256N32W8,
        };

        let final_verification =
            verify_lms_signature(&message, &lms_public_key, &final_lms_sig).unwrap();
        assert!(final_verification);
    }

    #[test]
    fn nist_cavp() {
        use hex;
        let nist_public_key_contents: Vec<u8> = hex::decode("0000000A00000006A754FC59A6DB4201BE5DEB20E464D6C1218B33FCB556347070E73394EA6675D1F383F08320475563").unwrap();
        let nist_message: Vec<u8> = hex::decode("FA2EBE17A797FC981FBD3906BE0049B5D8135840EEA60AEAED7D412741F4B8B411561A278521240BBA6E02B41000992500AD37BF9A25FB15554339CCA3B60622714A075725496310D3F265E9BC602E2649E5DE481729FE18AE4071E931F8FE2058BE143F27E30ADFF54FE9993DA956C72D6BC4A1D75FE186892E3B3029595FBC").unwrap();
        let nist_signature_contents: Vec<u8> = hex::decode("0000001A00000006969F7094C09F2783F4A5628D6CD620C0FF2DAB69CA4E489BF91AD0C633A7261F7C153704C368FB50A3E8F17F15C2104FE0E0CE5DD5373A792519CA6601D79BB4018D4CDBC4B7BCC0B198C9E84373738543DC6A23F9114404AF17ECD103FA58E4F9DEEB8CDEDCB7D87C51FA905DB1D1011C347CB1C7266462CC88FA2F91EAC87A9C4C585891CC2B0565DBEB2AEE38956B9E650AF2B18D6EC5CE10E3281392388A075FDA8B0EFB610E85652F2AAC3175FAA3F58B78AD355DB7AEC9FD471ED393EA371EF5A37B632BF760C89C2D8B6955577F3ACAFCC83710C76276E09922F762D94BC63F7DFDBCD950BED5EBD88352F6E843D8E0E5C302DECD98B56716C3D07EEF9E28DDF9B6D2EB67BF0B69539FF77860EE4F72FC43997DAB8B602862985E87641B8CBBCB37D171F61398CBD551C9036FD5B17EDAF784015EE2FCA1DB2D5DCFFBAD3AF16CC4C92BBFC7205A4FF793FB1192EF0029602BB6C152B34B1FA2C5DA3F8E348E91A82EA7761D666A3846C96712FB8944830B4921B3EC2654EFFAC36EE8DE6BB4851DD14192A2EE2B97CA0D6126CF8154870932744BB4D5A906881E3A6E01320FC3813F076606A8A0553DB95D3E1D63F52DB3CDC52E3FB1DF2E5DDE718BFBF354059566090D8B5CB5FC6929E691C19724B13D38CE54B45CFBFB87AD2DF84EA8D774FB43BC3C1BCB37C1314F8F8E4557B1ECC74A9B468EE981E49D0CEF647B53B9378868ADBE377805A6D6A30A83926AA65E79973D27618CBFF44628B639D1C01F583A6A2981602DBF5C642295556EB2B0890EBA4B90CDA10615001E0E67A9FBEBAD424728B21290E66B6B6DAB5B391027B26E3B91DE3135F501E793816DBEFD25D527001DA792ADE6DEF9416A11EF11180943E34B2A3E6E86E77414764B879F926699DA6E6371AA5776C7034216ADE57F411486BAB05D4030E56472C087D0D3C755CC47EB312F4D002E966BF2014CAB020642EEC0AFB40731E25CD14CEBD3D748E3E27FE4A53F1033E7F1C64380FA2C77E27A2D7DE1CE3C66159DC564DB80767B006AC92C51C806BB264FAB2C21CC975EE0A4FCC699F6E810EEF04C943398F16AE99AB5827A6E8A05759E0DFB13763E0FA1193FB0EE3ADF39751E295EE0066A87C38DF710E834D12083AC916619C626CADD3BB4FCFD1338BB62058C3DFEAE05D5773FCE2050AA498FAD5BEBE5658C1EB948B6CF8B8ACB03EA214FFCFA52DAEEDF8852D1BAAEF0899A6DEED52B2019DE1CFDB03F905B125C6CA7AECED57F7F5D97280BB041C2A739A5602D13B2B36E98E3F744487FF5E76A8D10EF97589DF92F71346DACBFEF7601F54E7A4AF1979DDD4385ED9DE9949E9222A72BA77D8F71E91BCBA02EB1DF54436415BFAD867D3AC6A53DB926C3054A536731DFC041F799A3715893F12C03505ADD9DFF8D980D762F7F72FB9B13BBCFCBC048304A89EDDC5553C5A3949FA4E65A2F105F9FEA075A8A371FF7CCBA30EBE8850523E04639D8C0F97D84F15691B4822676F23B86D6F52EDBF435DBC6F149D6F3ABBD2D7953A6F1A57FE36C8EDF881C29B306534CE48EA363CAD4512584B8D5C9AD57E37B9258688DA20BAC3127235F10A27DCB854E04A5069AF02D53C2C3EC527A22DB9FDA1D38B5688ADEDE605080BED7EA226C32210E4CEF412FEEC0264D8D5C8C80BF9D81F4F59E6AC0543606E603D35BB86C1D82CF97A109283C87CE7764078FD868661104DABDA80607CFDCE19A5C48ABFC8E53C6040B6C170B6B1B56B9AA2C7F9AA50068615322C27C72A9A7EC88C3FF9BA2DA6B49DE867DFC583E163EC21FCE82495DE9A1E30F69C7CD2735CFA07B9CBA140733C2C14D368F1063CB376B46088420992F8A00B753C42408E77B7DF6A36B4A773BF4F826DD3898B650C6E0AF3C1057CAD4833C3B74362352A11287121DFF52FA6903E8E7FB3E56061BE61CBA90C6B3131E49B5219E637B2E0FF8BFF88B90E8DD242CC92BEE4C8440A86681874A361E2D30A3D3F9EFD078956D30754B7156B50CA3A2303E36EA0946A953D76599D7FB7DCCED424929E63224BCE56F1D0548932F9C28E4F6A7F472ED531DDEDB97524C2E52C95F90A8A4A11EA0A2B894B75C2B20EACB96F8FF961006B9D41EC45F483697215C4CC69FF65A8DA5E9E0EE0B70D47F09D5D769F240FE71381431444A9797D4AAB7784A7A274030E31AED6DA76D839ACB2BC644DC20B231F1562E206B0E0F47C0AB0A20D3D71C26872C9FF6D7B760684BC623AA06AD319D7CC1729825776DB9EE775EFBEE9DC248250D1D860A89284B868F7ED426B62D10981E007B4358DA6D371ADE8F0E0C34241E002BDF85B3F85F6065AFBE31E5D5489FAB1CFAE4D5927045B03989B16466F5EC0BB54AB998D01C935E0C4F28305462ECFF3F551147F974D80012B8F64ECC05919A634C1E403F26D21AC102CA99D5996B6EC74625B6E3384D7122B910CD1A3F1ACEC341D7C38393AAA0068EAA2EF065F2B30B523D474040198C6BF60540B83AFD55F64AA3C252E31DE6B42A7318800BA4B9BD1CF2F19F7CAFFF7E1D75072B28242720729A718E50466F3E3CE3DACFD040965CBB2FCFDE73CCB29B4A6C39C7CEB22F0901CEC5D2807C1648713B210166010923B22917021A4DDCE61EAD3D2F33E739429F1D0A0FF17177EE19101834D95C80921BBCCF39005715F6DBCC1CC89CE33BBCA1026872FE5CBBFD71BEAD408D521A06424377323FDBC6F7EABC9B67D4B6C98DF1EB14A7A077A0FDA6EEA8ACDFE151AE96C8E6A7EF6E3A5EE8CEC7CD5AE389D3DDF386E903E36C167079CFE5BEF24286E9C2AE5BD0173762F0590EE8ADC6284F18CE15B0C4C385057C84E9DFF2ADD8A583407B5EF8C39F76122339136695795588F2C76F4FB59A9C9298B549406214D91001A5B3F9197F9C8FC255B3867FB1528C013649C013CEEF88A64A0FE7982542E9CD3FADB32A7D3B27038817143AC3A297D85A1DEDB32DF18F0F82CE1E14B5132886C3F9F7B192B9038DD300DDE1BCF5C8D25ED9602E62C73002E25D4EDE8B7D192D3B4C5BCB6F92EF50B5D9E11F626650C4E5FEA1F9EE19759902423290385F99897579843EE72FCD44090DBB46E4B7B006AFFA703A6FF2CDFECE60FDBC5447D26FA7DA9F5499D5439C92D32455FBB16AD0913A334E2B66561AEA11A3ABD0D305BB47F0C77C19BD7C504440C5BB78293AC5329C30D2342B47DFDF6D26194CB9C0F62D78F5C9ADD5BB177D7ECF2714BBA6FB0D3D6D9008EC8B4A53327A5B3ED11A5F5BE4EA3FC5BFC3B367111C360D0A8FB8C262CDF5AE9DDCB67577F51643EEB04851161C72AC2E50F63F2D2E1F7A56A402D2F9786481AE67AD8EF494D70B3083ACE490763FE626198F667B1F5A83F2242310267C70722AE3AEA1515F076130411E9F2B2DE76EEA2A4BD8F9034FB2CFC30020B1F080427AFC62F509385EB10559A11FF719E77F4CCC2D223722F2499362DF87FB0000000A5BBA015AE344140386200F1CFB23C96D257A0BC467BCFA59EEC2E7E5D55EA9F7EA8AA7CDD3C09BD4D846E5E3AECC336EE2213A29BE684482EDEB3246C3F09056B3260D9884543047856CE7E2EA0FFCF960B94B702E001FACCE6C90557D2BC72E1D5F67FB4115112CF27D8B8F727A12B788174D40C60BF5A6").unwrap();

        let public_key = parse_public_contents::<24>(&nist_public_key_contents).unwrap();
        let lms_sig = parse_signature_contents::<24>(&nist_signature_contents).unwrap();

        let full_sig = LmsSignature {
            q: lms_sig.q,
            ots_type: lms_sig.ots_type,
            nonce: lms_sig.nonce,
            y: lms_sig.y.to_vec(),
            lms_type: public_key.lms_type,
            path: lms_sig.path,
        };

        let success = verify_lms_signature(&nist_message, &public_key, &full_sig).unwrap();
        assert!(success);
    }

    #[test]
    fn lms_failure() {
        let message: [u8; 162] = [
            0x54, 0x68, 0x65, 0x20, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x73, 0x20, 0x6e, 0x6f, 0x74,
            0x20, 0x64, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,
            0x74, 0x68, 0x65, 0x20, 0x55, 0x6e, 0x69, 0x74, 0x65, 0x64, 0x20, 0x53, 0x74, 0x61,
            0x74, 0x65, 0x73, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e,
            0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x6e, 0x6f, 0x72,
            0x20, 0x70, 0x72, 0x6f, 0x68, 0x69, 0x62, 0x69, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79,
            0x20, 0x69, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x74, 0x61,
            0x74, 0x65, 0x73, 0x2c, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72,
            0x76, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x74, 0x61,
            0x74, 0x65, 0x73, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65,
            0x6c, 0x79, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
            0x70, 0x65, 0x6f, 0x70, 0x6c, 0x65, 0x2e, 0x0a,
        ];
        let lms_public_identifier: LmsIdentifier = [
            0xd1, 0xf1, 0x4f, 0xf6, 0x34, 0x6a, 0xf9, 0x64, 0x56, 0x9f, 0x7d, 0x6c, 0xb8, 0x80,
            0xa1, 0xb6,
        ];

        let lms_public_key = Sha256Digest::from([
            0x6c, 0x50, 0x04, 0x91, 0x7d, 0xa6, 0xea, 0xfe, 0x4d, 0x9e, 0xf6, 0xc6, 0x40, 0x7b,
            0x3d, 0xb0, 0xe5, 0x48, 0x5b, 0x12, 0x2d, 0x9e, 0xbe, 0x15, 0xcd, 0xa9, 0x3c, 0xfe,
            0xc5, 0x82, 0xd7, 0xab,
        ]);

        // final signature
        let lms_q = 0xa;
        let final_c: [u8; 32] = [
            0x07, 0x03, 0xc4, 0x91, 0xe7, 0x55, 0x8b, 0x35, 0x01, 0x1e, 0xce, 0x35, 0x92, 0xea,
            0xa5, 0xda, 0x4d, 0x91, 0x87, 0x86, 0x77, 0x12, 0x33, 0xe8, 0x35, 0x3b, 0xc4, 0xf6,
            0x23, 0x23, 0x18, 0x5c,
        ];
        let final_y: [Sha256Digest; 34] = [
            Sha256Digest::from([
                0x95, 0xca, 0xe0, 0x5b, 0x89, 0x9e, 0x35, 0xdf, 0xfd, 0x71, 0x70, 0x54, 0x70, 0x62,
                0x09, 0x98, 0x8e, 0xbf, 0xdf, 0x6e, 0x37, 0x96, 0x0b, 0xb5, 0xc3, 0x8d, 0x76, 0x57,
                0xe8, 0xbf, 0xfe, 0xef,
            ]),
            Sha256Digest::from([
                0x9b, 0xc0, 0x42, 0xda, 0x4b, 0x45, 0x25, 0x65, 0x04, 0x85, 0xc6, 0x6d, 0x0c, 0xe1,
                0x9b, 0x31, 0x75, 0x87, 0xc6, 0xba, 0x4b, 0xff, 0xcc, 0x42, 0x8e, 0x25, 0xd0, 0x89,
                0x31, 0xe7, 0x2d, 0xfb,
            ]),
            Sha256Digest::from([
                0x6a, 0x12, 0x0c, 0x56, 0x12, 0x34, 0x42, 0x58, 0xb8, 0x5e, 0xfd, 0xb7, 0xdb, 0x1d,
                0xb9, 0xe1, 0x86, 0x5a, 0x73, 0xca, 0xf9, 0x65, 0x57, 0xeb, 0x39, 0xed, 0x3e, 0x3f,
                0x42, 0x69, 0x33, 0xac,
            ]),
            Sha256Digest::from([
                0x9e, 0xed, 0xdb, 0x03, 0xa1, 0xd2, 0x37, 0x4a, 0xf7, 0xbf, 0x77, 0x18, 0x55, 0x77,
                0x45, 0x62, 0x37, 0xf9, 0xde, 0x2d, 0x60, 0x11, 0x3c, 0x23, 0xf8, 0x46, 0xdf, 0x26,
                0xfa, 0x94, 0x20, 0x08,
            ]),
            Sha256Digest::from([
                0xa6, 0x98, 0x99, 0x4c, 0x08, 0x27, 0xd9, 0x0e, 0x86, 0xd4, 0x3e, 0x0d, 0xf7, 0xf4,
                0xbf, 0xcd, 0xb0, 0x9b, 0x86, 0xa3, 0x73, 0xb9, 0x82, 0x88, 0xb7, 0x09, 0x4a, 0xd8,
                0x1a, 0x01, 0x85, 0xac,
            ]),
            Sha256Digest::from([
                0x10, 0x0e, 0x4f, 0x2c, 0x5f, 0xc3, 0x8c, 0x00, 0x3c, 0x1a, 0xb6, 0xfe, 0xa4, 0x79,
                0xeb, 0x2f, 0x5e, 0xbe, 0x48, 0xf5, 0x84, 0xd7, 0x15, 0x9b, 0x8a, 0xda, 0x03, 0x58,
                0x6e, 0x65, 0xad, 0x9c,
            ]),
            Sha256Digest::from([
                0x96, 0x9f, 0x6a, 0xec, 0xbf, 0xe4, 0x4c, 0xf3, 0x56, 0x88, 0x8a, 0x7b, 0x15, 0xa3,
                0xff, 0x07, 0x4f, 0x77, 0x17, 0x60, 0xb2, 0x6f, 0x9c, 0x04, 0x88, 0x4e, 0xe1, 0xfa,
                0xa3, 0x29, 0xfb, 0xf4,
            ]),
            Sha256Digest::from([
                0xe6, 0x1a, 0xf2, 0x3a, 0xee, 0x7f, 0xa5, 0xd4, 0xd9, 0xa5, 0xdf, 0xcf, 0x43, 0xc4,
                0xc2, 0x6c, 0xe8, 0xae, 0xa2, 0xce, 0x8a, 0x29, 0x90, 0xd7, 0xba, 0x7b, 0x57, 0x10,
                0x8b, 0x47, 0xda, 0xbf,
            ]),
            Sha256Digest::from([
                0xbe, 0xad, 0xb2, 0xb2, 0x5b, 0x3c, 0xac, 0xc1, 0xac, 0x0c, 0xef, 0x34, 0x6c, 0xbb,
                0x90, 0xfb, 0x04, 0x4b, 0xee, 0xe4, 0xfa, 0xc2, 0x60, 0x3a, 0x44, 0x2b, 0xdf, 0x7e,
                0x50, 0x72, 0x43, 0xb7,
            ]),
            Sha256Digest::from([
                0x31, 0x9c, 0x99, 0x44, 0xb1, 0x58, 0x6e, 0x89, 0x9d, 0x43, 0x1c, 0x7f, 0x91, 0xbc,
                0xcc, 0xc8, 0x69, 0x0d, 0xbf, 0x59, 0xb2, 0x83, 0x86, 0xb2, 0x31, 0x5f, 0x3d, 0x36,
                0xef, 0x2e, 0xaa, 0x3c,
            ]),
            Sha256Digest::from([
                0xf3, 0x0b, 0x2b, 0x51, 0xf4, 0x8b, 0x71, 0xb0, 0x03, 0xdf, 0xb0, 0x82, 0x49, 0x48,
                0x42, 0x01, 0x04, 0x3f, 0x65, 0xf5, 0xa3, 0xef, 0x6b, 0xbd, 0x61, 0xdd, 0xfe, 0xe8,
                0x1a, 0xca, 0x9c, 0xe6,
            ]),
            Sha256Digest::from([
                0x00, 0x81, 0x26, 0x2a, 0x00, 0x00, 0x04, 0x80, 0xdc, 0xbc, 0x9a, 0x3d, 0xa6, 0xfb,
                0xef, 0x5c, 0x1c, 0x0a, 0x55, 0xe4, 0x8a, 0x0e, 0x72, 0x9f, 0x91, 0x84, 0xfc, 0xb1,
                0x40, 0x7c, 0x31, 0x52,
            ]),
            Sha256Digest::from([
                0x9d, 0xb2, 0x68, 0xf6, 0xfe, 0x50, 0x03, 0x2a, 0x36, 0x3c, 0x98, 0x01, 0x30, 0x68,
                0x37, 0xfa, 0xfa, 0xbd, 0xf9, 0x57, 0xfd, 0x97, 0xea, 0xfc, 0x80, 0xdb, 0xd1, 0x65,
                0xe4, 0x35, 0xd0, 0xe2,
            ]),
            Sha256Digest::from([
                0xdf, 0xd8, 0x36, 0xa2, 0x8b, 0x35, 0x40, 0x23, 0x92, 0x4b, 0x6f, 0xb7, 0xe4, 0x8b,
                0xc0, 0xb3, 0xed, 0x95, 0xee, 0xa6, 0x4c, 0x2d, 0x40, 0x2f, 0x4d, 0x73, 0x4c, 0x8d,
                0xc2, 0x6f, 0x3a, 0xc5,
            ]),
            Sha256Digest::from([
                0x91, 0x82, 0x5d, 0xae, 0xf0, 0x1e, 0xae, 0x3c, 0x38, 0xe3, 0x32, 0x8d, 0x00, 0xa7,
                0x7d, 0xc6, 0x57, 0x03, 0x4f, 0x28, 0x7c, 0xcb, 0x0f, 0x0e, 0x1c, 0x9a, 0x7c, 0xbd,
                0xc8, 0x28, 0xf6, 0x27,
            ]),
            Sha256Digest::from([
                0x20, 0x5e, 0x47, 0x37, 0xb8, 0x4b, 0x58, 0x37, 0x65, 0x51, 0xd4, 0x4c, 0x12, 0xc3,
                0xc2, 0x15, 0xc8, 0x12, 0xa0, 0x97, 0x07, 0x89, 0xc8, 0x3d, 0xe5, 0x1d, 0x6a, 0xd7,
                0x87, 0x27, 0x19, 0x63,
            ]),
            Sha256Digest::from([
                0x32, 0x7f, 0x0a, 0x5f, 0xbb, 0x6b, 0x59, 0x07, 0xde, 0xc0, 0x2c, 0x9a, 0x90, 0x93,
                0x4a, 0xf5, 0xa1, 0xc6, 0x3b, 0x72, 0xc8, 0x26, 0x53, 0x60, 0x5d, 0x1d, 0xcc, 0xe5,
                0x15, 0x96, 0xb3, 0xc2,
            ]),
            Sha256Digest::from([
                0xb4, 0x56, 0x96, 0x68, 0x9f, 0x2e, 0xb3, 0x82, 0x00, 0x74, 0x97, 0x55, 0x76, 0x92,
                0xca, 0xac, 0x4d, 0x57, 0xb5, 0xde, 0x9f, 0x55, 0x69, 0xbc, 0x2a, 0xd0, 0x13, 0x7f,
                0xd4, 0x7f, 0xb4, 0x7e,
            ]),
            Sha256Digest::from([
                0x66, 0x4f, 0xcb, 0x6d, 0xb4, 0x97, 0x1f, 0x5b, 0x3e, 0x07, 0xac, 0xed, 0xa9, 0xac,
                0x13, 0x0e, 0x9f, 0x38, 0x18, 0x2d, 0xe9, 0x94, 0xcf, 0xf1, 0x92, 0xec, 0x0e, 0x82,
                0xfd, 0x6d, 0x4c, 0xb7,
            ]),
            Sha256Digest::from([
                0xf3, 0xfe, 0x00, 0x81, 0x25, 0x89, 0xb7, 0xa7, 0xce, 0x51, 0x54, 0x40, 0x45, 0x64,
                0x33, 0x01, 0x6b, 0x84, 0xa5, 0x9b, 0xec, 0x66, 0x19, 0xa1, 0xc6, 0xc0, 0xb3, 0x7d,
                0xd1, 0x45, 0x0e, 0xd4,
            ]),
            Sha256Digest::from([
                0xf2, 0xd8, 0xb5, 0x84, 0x41, 0x0c, 0xed, 0xa8, 0x02, 0x5f, 0x5d, 0x2d, 0x8d, 0xd0,
                0xd2, 0x17, 0x6f, 0xc1, 0xcf, 0x2c, 0xc0, 0x6f, 0xa8, 0xc8, 0x2b, 0xed, 0x4d, 0x94,
                0x4e, 0x71, 0x33, 0x9e,
            ]),
            Sha256Digest::from([
                0xce, 0x78, 0x0f, 0xd0, 0x25, 0xbd, 0x41, 0xec, 0x34, 0xeb, 0xff, 0x9d, 0x42, 0x70,
                0xa3, 0x22, 0x4e, 0x01, 0x9f, 0xcb, 0x44, 0x44, 0x74, 0xd4, 0x82, 0xfd, 0x2d, 0xbe,
                0x75, 0xef, 0xb2, 0x03,
            ]),
            Sha256Digest::from([
                0x89, 0xcc, 0x10, 0xcd, 0x60, 0x0a, 0xbb, 0x54, 0xc4, 0x7e, 0xde, 0x93, 0xe0, 0x8c,
                0x11, 0x4e, 0xdb, 0x04, 0x11, 0x7d, 0x71, 0x4d, 0xc1, 0xd5, 0x25, 0xe1, 0x1b, 0xed,
                0x87, 0x56, 0x19, 0x2f,
            ]),
            Sha256Digest::from([
                0x92, 0x9d, 0x15, 0x46, 0x2b, 0x93, 0x9f, 0xf3, 0xf5, 0x2f, 0x22, 0x52, 0xda, 0x2e,
                0xd6, 0x4d, 0x8f, 0xae, 0x88, 0x81, 0x8b, 0x1e, 0xfa, 0x2c, 0x7b, 0x08, 0xc8, 0x79,
                0x4f, 0xb1, 0xb2, 0x14,
            ]),
            Sha256Digest::from([
                0xaa, 0x23, 0x3d, 0xb3, 0x16, 0x28, 0x33, 0x14, 0x1e, 0xa4, 0x38, 0x3f, 0x1a, 0x6f,
                0x12, 0x0b, 0xe1, 0xdb, 0x82, 0xce, 0x36, 0x30, 0xb3, 0x42, 0x91, 0x14, 0x46, 0x31,
                0x57, 0xa6, 0x4e, 0x91,
            ]),
            Sha256Digest::from([
                0x23, 0x4d, 0x47, 0x5e, 0x2f, 0x79, 0xcb, 0xf0, 0x5e, 0x4d, 0xb6, 0xa9, 0x40, 0x7d,
                0x72, 0xc6, 0xbf, 0xf7, 0xd1, 0x19, 0x8b, 0x5c, 0x4d, 0x6a, 0xad, 0x28, 0x31, 0xdb,
                0x61, 0x27, 0x49, 0x93,
            ]),
            Sha256Digest::from([
                0x71, 0x5a, 0x01, 0x82, 0xc7, 0xdc, 0x80, 0x89, 0xe3, 0x2c, 0x85, 0x31, 0xde, 0xed,
                0x4f, 0x74, 0x31, 0xc0, 0x7c, 0x02, 0x19, 0x5e, 0xba, 0x2e, 0xf9, 0x1e, 0xfb, 0x56,
                0x13, 0xc3, 0x7a, 0xf7,
            ]),
            Sha256Digest::from([
                0xae, 0x0c, 0x06, 0x6b, 0xab, 0xc6, 0x93, 0x69, 0x70, 0x0e, 0x1d, 0xd2, 0x6e, 0xdd,
                0xc0, 0xd2, 0x16, 0xc7, 0x81, 0xd5, 0x6e, 0x4c, 0xe4, 0x7e, 0x33, 0x03, 0xfa, 0x73,
                0x00, 0x7f, 0xf7, 0xb9,
            ]),
            Sha256Digest::from([
                0x49, 0xef, 0x23, 0xbe, 0x2a, 0xa4, 0xdb, 0xf2, 0x52, 0x06, 0xfe, 0x45, 0xc2, 0x0d,
                0xd8, 0x88, 0x39, 0x5b, 0x25, 0x26, 0x39, 0x1a, 0x72, 0x49, 0x96, 0xa4, 0x41, 0x56,
                0xbe, 0xac, 0x80, 0x82,
            ]),
            Sha256Digest::from([
                0x12, 0x85, 0x87, 0x92, 0xbf, 0x8e, 0x74, 0xcb, 0xa4, 0x9d, 0xee, 0x5e, 0x88, 0x12,
                0xe0, 0x19, 0xda, 0x87, 0x45, 0x4b, 0xff, 0x9e, 0x84, 0x7e, 0xd8, 0x3d, 0xb0, 0x7a,
                0xf3, 0x13, 0x74, 0x30,
            ]),
            Sha256Digest::from([
                0x82, 0xf8, 0x80, 0xa2, 0x78, 0xf6, 0x82, 0xc2, 0xbd, 0x0a, 0xd6, 0x88, 0x7c, 0xb5,
                0x9f, 0x65, 0x2e, 0x15, 0x59, 0x87, 0xd6, 0x1b, 0xbf, 0x6a, 0x88, 0xd3, 0x6e, 0xe9,
                0x3b, 0x60, 0x72, 0xe6,
            ]),
            Sha256Digest::from([
                0x65, 0x6d, 0x9c, 0xcb, 0xaa, 0xe3, 0xd6, 0x55, 0x85, 0x2e, 0x38, 0xde, 0xb3, 0xa2,
                0xdc, 0xf8, 0x05, 0x8d, 0xc9, 0xfb, 0x6f, 0x2a, 0xb3, 0xd3, 0xb3, 0x53, 0x9e, 0xb7,
                0x7b, 0x24, 0x8a, 0x66,
            ]),
            Sha256Digest::from([
                0x10, 0x91, 0xd0, 0x5e, 0xb6, 0xe2, 0xf2, 0x97, 0x77, 0x4f, 0xe6, 0x05, 0x35, 0x98,
                0x45, 0x7c, 0xc6, 0x19, 0x08, 0x31, 0x8d, 0xe4, 0xb8, 0x26, 0xf0, 0xfc, 0x86, 0xd4,
                0xbb, 0x11, 0x7d, 0x33,
            ]),
            Sha256Digest::from([
                0xe8, 0x65, 0xaa, 0x80, 0x50, 0x09, 0xcc, 0x29, 0x18, 0xd9, 0xc2, 0xf8, 0x40, 0xc4,
                0xda, 0x43, 0xa7, 0x03, 0xad, 0x9f, 0x5b, 0x58, 0x06, 0x16, 0x3d, 0x71, 0x61, 0x69,
                0x6b, 0x5a, 0x0a, 0xdc,
            ]),
        ];

        let final_path: [Sha256Digest; 5] = [
            Sha256Digest::from([
                0xd5, 0xc0, 0xd1, 0xbe, 0xbb, 0x06, 0x04, 0x8e, 0xd6, 0xfe, 0x2e, 0xf2, 0xc6, 0xce,
                0xf3, 0x05, 0xb3, 0xed, 0x63, 0x39, 0x41, 0xeb, 0xc8, 0xb3, 0xbe, 0xc9, 0x73, 0x87,
                0x54, 0xcd, 0xdd, 0x60,
            ]),
            Sha256Digest::from([
                0xe1, 0x92, 0x0a, 0xda, 0x52, 0xf4, 0x3d, 0x05, 0x5b, 0x50, 0x31, 0xce, 0xe6, 0x19,
                0x25, 0x20, 0xd6, 0xa5, 0x11, 0x55, 0x14, 0x85, 0x1c, 0xe7, 0xfd, 0x44, 0x8d, 0x4a,
                0x39, 0xfa, 0xe2, 0xab,
            ]),
            Sha256Digest::from([
                0x23, 0x35, 0xb5, 0x25, 0xf4, 0x84, 0xe9, 0xb4, 0x0d, 0x6a, 0x4a, 0x96, 0x93, 0x94,
                0x84, 0x3b, 0xdc, 0xf6, 0xd1, 0x4c, 0x48, 0xe8, 0x01, 0x5e, 0x08, 0xab, 0x92, 0x66,
                0x2c, 0x05, 0xc6, 0xe9,
            ]),
            Sha256Digest::from([
                0xf9, 0x0b, 0x65, 0xa7, 0xa6, 0x20, 0x16, 0x89, 0x99, 0x9f, 0x32, 0xbf, 0xd3, 0x68,
                0xe5, 0xe3, 0xec, 0x9c, 0xb7, 0x0a, 0xc7, 0xb8, 0x39, 0x90, 0x03, 0xf1, 0x75, 0xc4,
                0x08, 0x85, 0x08, 0x1a,
            ]),
            Sha256Digest::from([
                0x09, 0xab, 0x30, 0x34, 0x91, 0x1f, 0xe1, 0x25, 0x63, 0x10, 0x51, 0xdf, 0x04, 0x08,
                0xb3, 0x94, 0x6b, 0x0b, 0xde, 0x79, 0x09, 0x11, 0xe8, 0x97, 0x8b, 0xa0, 0x7d, 0xd5,
                0x6c, 0x73, 0xe7, 0xee,
            ]),
        ];

        let final_ots_sig = LmotsSignature {
            ots_type: LmotsAlgorithmType::LmotsSha256N32W8,
            nonce: final_c,
            y: final_y.to_vec(),
        };

        let final_lms_sig = LmsSignature {
            q: lms_q,
            ots_type: final_ots_sig.ots_type,
            nonce: final_ots_sig.nonce,
            y: final_ots_sig.y,
            lms_type: LmsAlgorithmType::LmsSha256N32H5,
            path: Vec::from(final_path),
        };

        let lms_public_key = LmsPublicKey {
            lms_identifier: lms_public_identifier,
            root_hash: lms_public_key,
            lms_type: LmsAlgorithmType::LmsSha256N32H5,
            lmots_type: LmotsAlgorithmType::LmotsSha256N32W8,
        };

        let final_verification =
            verify_lms_signature(&message, &lms_public_key, &final_lms_sig).unwrap();
        assert!(!final_verification);
    }
}
