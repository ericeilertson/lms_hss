use byteorder::{BigEndian, ByteOrder};
use rand::random;
use sha2::{Digest, Sha256};

const D_PBLC: u16 = 0x8080;
const D_MESG: u16 = 0x8181;
const D_LEAF: u16 = 0x8282;
const D_INTR: u16 = 0x8383;

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct HashValue<const N: usize>([u8; N]);

impl<const N: usize> Default for HashValue<N> {
    fn default() -> Self {
        let data = [0u8; N];
        HashValue(data)
    }
}

impl<const N: usize> From<[u8; N]> for HashValue<N> {
    fn from(data: [u8; N]) -> Self {
        HashValue(data)
    }
}

impl From<[u8; 32]> for HashValue<24> {
    fn from(data: [u8; 32]) -> Self {
        let mut t = [0u8; 24];
        for index in 0..24 {
            t[index] = data[index];
        }
        HashValue(t)
    }
}

impl<const N: usize> AsRef<[u8]> for HashValue<N> {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

pub type Sha256Digest = HashValue<32>;
pub type Sha192Digest = HashValue<24>;
pub type LmsIdentifier = [u8; 16];

#[derive(Debug, PartialEq, Eq, Hash)]
pub enum LmotsAlgorithmType {
    LmotsReserved = 0,
    LmotsSha256N32W1 = 1,
    LmotsSha256N32W2 = 2,
    LmotsSha256N32W4 = 3,
    LmotsSha256N32W8 = 4,
    LmotsSha256N24W1 = 5,
    LmotsSha256N24W2 = 6,
    LmotsSha256N24W4 = 7,
    LmotsSha256N24W8 = 8,
}

#[derive(Debug)]
pub enum LmsAlgorithmType {
    LmsReserved = 0,
    LmsSha256N32H5 = 5,
    LmsSha256N32H10 = 6,
    LmsSha256N32H15 = 7,
    LmsSha256N32H20 = 8,
    LmsSha256N32H25 = 9,
    LmsSha256N24H5 = 10,
    LmsSha256N24H10 = 11,
    LmsSha256N24H15 = 12,
    LmsSha256N24H20 = 13,
    LmsSha256N24H25 = 14,
}
#[derive(Debug)]
pub struct LmotsSignature {
    ots_type: LmotsAlgorithmType,
    nonce: [u8; 32],
    y: Vec<Sha256Digest>,
}

#[derive(Debug)]
pub struct LmsSignature {
    pub q: u32,
    pub lmots_signature: LmotsSignature,
    pub sig_type: LmsAlgorithmType,
    pub lms_path: Vec<Sha256Digest>,
}

#[derive(Debug)]
pub struct LmotsParameter {
    algorithm_name: LmotsAlgorithmType,
    n: u8,
    w: u8,
    p: u16,
    ls: u8,
    sig_len: u16,
}

const LMOTS_P: [LmotsParameter; 9] = [
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsReserved,
        n: 0,
        w: 0,
        p: 0,
        ls: 0,
        sig_len: 0,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W1,
        n: 32,
        w: 1,
        p: 265,
        ls: 7,
        sig_len: 8516,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W2,
        n: 32,
        w: 2,
        p: 133,
        ls: 6,
        sig_len: 4292,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W4,
        n: 32,
        w: 4,
        p: 67,
        ls: 4,
        sig_len: 2180,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W8,
        n: 32,
        w: 8,
        p: 34,
        ls: 0,
        sig_len: 1124,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W1,
        n: 24,
        w: 1,
        p: 200,
        ls: 8,
        sig_len: 4828,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W2,
        n: 24,
        w: 2,
        p: 101,
        ls: 6,
        sig_len: 2452,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W4,
        n: 24,
        w: 4,
        p: 51,
        ls: 4,
        sig_len: 1252,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W8,
        n: 24,
        w: 8,
        p: 26,
        ls: 0,
        sig_len: 652,
    },
];

//do we actually need these?
fn u32str(i: u32) -> [u8; 4] {
    let mut buf = [0; 4];
    BigEndian::write_u32(&mut buf, i);
    return buf;
}

fn u16str(i: u16) -> [u8; 2] {
    let mut buf = [0; 2];
    BigEndian::write_u16(&mut buf, i);
    return buf;
}

fn u8str(i: u8) -> [u8; 1] {
    let mut buf = [0; 1];
    buf[0] = i;
    return buf;
}

pub fn get_lmots_parameters(algo_type: &LmotsAlgorithmType) -> &'static LmotsParameter {
    for i in &LMOTS_P {
        if i.algorithm_name == *algo_type {
            return i;
        }
    }
    panic!("Its all screwed")
}

pub fn get_lms_parameters(algo_type: &LmsAlgorithmType) -> (u8, u8) {
    match algo_type {
        LmsAlgorithmType::LmsSha256N32H5 => (32, 5),
        LmsAlgorithmType::LmsSha256N32H10 => (32, 10),
        LmsAlgorithmType::LmsSha256N32H15 => (32, 15),
        LmsAlgorithmType::LmsSha256N32H20 => (32, 20),
        LmsAlgorithmType::LmsSha256N32H25 => (32, 25),
        LmsAlgorithmType::LmsSha256N24H5 => (24, 5),
        LmsAlgorithmType::LmsSha256N24H10 => (24, 10),
        LmsAlgorithmType::LmsSha256N24H15 => (24, 15),
        LmsAlgorithmType::LmsSha256N24H20 => (24, 20),
        LmsAlgorithmType::LmsSha256N24H25 => (24, 25),
        LmsAlgorithmType::LmsReserved => {
            panic!("Its all screwed")
        }
    }
}

// follows pseudo code at https://www.rfc-editor.org/rfc/rfc8554#section-3.1.3
fn coefficient(s: &[u8], i: usize, w: usize) -> u8 {
    let blah: u16 = (1 << (w)) - 1;
    let index = i * w / 8;
    let b = s[index as usize];

    // extra logic to avoid the divide by 0
    // which a good compiler would notice only happens when w is 0 and that portion of the
    // expression could be skipped
    let mut shift = 8;
    if w != 0 {
        shift = 8 - (w * (i % (8 / w)) + w);
    }

    // Rust errors if we try to shift off all of the bits off from a value
    // some implementations 0 fill, others do some other filling.
    // we make this be 0
    let mut rs = 0;
    if shift < 8 {
        rs = b >> shift;
    }
    let small_blah = blah as u8;
    return small_blah & rs;
}

fn create_lmots_private_key(algo_type: &LmotsAlgorithmType) -> Vec<[u8; 32]> {
    let params = get_lmots_parameters(algo_type);
    let mut x = vec![];
    for _ in 0..params.p {
        let tmp: [u8; 32] = random();
        x.push(tmp);
    }
    return x;
}

fn calculate_ots_public_key(
    algo_type: &LmotsAlgorithmType,
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
    x: &Vec<[u8; 32]>,
) -> Sha256Digest {
    let params = get_lmots_parameters(algo_type);
    let mut y = vec![[0u8; 32]; params.p as usize];
    for (i, xi) in x.iter().enumerate() {
        let mut tmp = xi.clone();
        let upper = (1 << params.w) - 1;
        for j in 0..upper {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(q);
            hasher.update(u16str(i as u16));
            hasher.update(u8str(j as u8));
            hasher.update(tmp);
            let result = hasher.finalize();
            for (index, b) in result.iter().enumerate() {
                tmp[index] = *b;
            }
        }
        y[i] = tmp.clone();
    }
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(u16str(D_PBLC));
    for t in y {
        hasher.update(t);
    }
    let result = hasher.finalize();
    let mut final_result = [0u8; 32];
    for (index, b) in result.iter().enumerate() {
        final_result[index] = *b;
    }
    let return_value = Sha256Digest::from(final_result);
    return return_value;
}

// this is copied derived from section 5.2 of rfc 8554
fn create_lms_private_keys(
    tree_height: u8,
    ots_type: &LmotsAlgorithmType,
) -> (LmsIdentifier, u32, Vec<Vec<[u8; 32]>>) {
    let lms_identifier: LmsIdentifier = random();
    let upper = 1 << tree_height;
    let mut ots_private = vec![];
    for _ in 0..upper {
        ots_private.push(create_lmots_private_key(ots_type));
    }
    return (lms_identifier, 0, ots_private);
}

pub fn create_lms_tree(
    lms_type: &LmsAlgorithmType,
    ots_type: &LmotsAlgorithmType,
) -> (LmsIdentifier, u32, Vec<Sha256Digest>, Vec<Vec<[u8; 32]>>) {
    let (_, tree_height) = get_lms_parameters(lms_type);
    let num_nodes = 1 << tree_height + 1; // we will instantiate an array to store the entire tree
    let mut t_tree = vec![Sha256Digest::default(); num_nodes]; // the tree root will be at t_tree[1]
    let (lms_identifier, initial_q, private_keys) = create_lms_private_keys(tree_height, ots_type);
    if num_nodes != 2 * private_keys.len() {
        panic!("The tree needs to be twice the size of the number of private keys");
    }
    // Copy the public keys of the leaves into the leaves of the tree
    let initial_offset = private_keys.len();
    for offset in 0..private_keys.len() {
        let q = u32str(offset as u32);
        let ots_key =
            calculate_ots_public_key(ots_type, &lms_identifier, &q, &private_keys[offset]);
        let mut hasher = Sha256::new();
        hasher.update(lms_identifier);
        let r = (initial_offset + offset) as u32;
        hasher.update(u32str(r));
        hasher.update(u16str(D_LEAF));
        hasher.update(ots_key);
        let t_temp = hasher.finalize();
        let mut temp = [0u8; 32];
        for (index, b) in t_temp.iter().enumerate() {
            temp[index] = *b;
        }
        t_tree[initial_offset + offset] = Sha256Digest::from(temp);
    }
    // Now process each layer of tree from the bottom up
    for level in (1..(tree_height + 1)).rev() {
        let initial_offset = 1 << (level - 1);
        for offset in 0..initial_offset {
            let node_num = offset + initial_offset;
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(u32str(node_num));
            hasher.update(u16str(D_INTR));
            hasher.update(t_tree[2 * node_num as usize]);
            hasher.update(t_tree[(2 * node_num) as usize + 1]);

            let t_temp = hasher.finalize();
            let mut temp = [0u8; 32];
            for (index, b) in t_temp.iter().enumerate() {
                temp[index] = *b;
            }
            t_tree[node_num as usize] = Sha256Digest::from(temp);
        }
    }

    return (lms_identifier, initial_q, t_tree, private_keys);
}

fn checksum(algo_type: &LmotsAlgorithmType, input_string: &[u8]) -> u16 {
    let params = get_lmots_parameters(algo_type);
    let mut sum = 0u16;
    let upper_bound = params.n as u16 * (8 / params.w as u16);
    for i in 0..upper_bound {
        sum = sum + ((1 << params.w) - 1)
            - (coefficient(input_string, i as usize, params.w as usize) as u16);
    }
    let shifted = sum << params.ls;
    return shifted;
}

fn lmots_sign_message(
    algo_type: &LmotsAlgorithmType,
    input_string: &[u8],
    private_key: &Vec<[u8; 32]>,
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
) -> LmotsSignature {
    let params = get_lmots_parameters(algo_type);
    let nonce: [u8; 32] = random(); // in the RFC this is the C value

    let mut y = vec![Sha256Digest::default(); params.p as usize];
    assert_eq!(private_key.len(), params.p as usize);
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(u16str(D_MESG));
    hasher.update(nonce);
    hasher.update(input_string);
    let tq = hasher.finalize();
    let mut message_hash_with_checksum = [0u8; 34]; // 2 extra bytes for the checksum.  assumes sha256
    for (index, b) in tq.iter().enumerate() {
        message_hash_with_checksum[index] = *b;
    }
    let checksum_q = checksum(algo_type, &message_hash_with_checksum);
    let be_checksum = u16str(checksum_q);
    message_hash_with_checksum[32] = be_checksum[0];
    message_hash_with_checksum[33] = be_checksum[1];

    for i in 0..params.p {
        let a = coefficient(&message_hash_with_checksum, i as usize, params.w as usize);
        let mut tmp = private_key[i as usize].clone();
        for j in 0..a {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(q);
            hasher.update(u16str(i));
            hasher.update(u8str(j));
            hasher.update(tmp);
            let tt = hasher.finalize();
            for (index, b) in tt.iter().enumerate() {
                tmp[index] = *b;
            }
        }
        y[i as usize] = Sha256Digest::from(tmp.clone());
    }
    // TODO make this not hard coded type
    // currently ots_type is never checked anyway
    let signature = LmotsSignature {
        ots_type: LmotsAlgorithmType::LmotsSha256N32W4,
        nonce,
        y,
    };
    return signature;
}

fn candidate_ots_signature(
    algo_type: &LmotsAlgorithmType,
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
    signature: &LmotsSignature,
    message: &[u8],
) -> Sha256Digest {
    let params = get_lmots_parameters(algo_type);
    let mut hasher = Sha256::new();
    let mut z = vec![Sha256Digest::default(); params.p as usize];
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(u16str(D_MESG));
    hasher.update(signature.nonce);
    hasher.update(message);
    let tq = hasher.finalize();
    let mut message_hash_with_checksum = [0u8; 34]; // 2 extra bytes for the checksum
    for (index, b) in tq.iter().enumerate() {
        message_hash_with_checksum[index] = *b;
    }
    let checksum_q = checksum(algo_type, &message_hash_with_checksum);
    let be_checksum = u16str(checksum_q);
    message_hash_with_checksum[32] = be_checksum[0];
    message_hash_with_checksum[33] = be_checksum[1];

    for i in 0..params.p {
        let a = coefficient(&message_hash_with_checksum, i as usize, params.w as usize);
        let mut tmp = signature.y[i as usize].clone();
        let t_upper: u16 = (1 << params.w) - 1; // subtract with overflow?
        let upper = t_upper as u8;
        for j in a..upper {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(q);
            hasher.update(u16str(i));
            hasher.update(u8str(j));
            hasher.update(tmp);
            let tt = hasher.finalize();
            let mut blah = [0u8; 32];
            for (index, b) in tt.iter().enumerate() {
                blah[index] = *b;
            }
            tmp = Sha256Digest::from(blah);
        }
        z[i as usize] = tmp;
    }
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(u16str(D_PBLC));
    for t in z {
        hasher.update(t);
    }
    let result = hasher.finalize();
    let mut final_result = [0u8; 32];
    for (index, b) in result.iter().enumerate() {
        final_result[index] = *b;
    }
    return Sha256Digest::from(final_result);
}

fn verify_ots_signature(
    algo_type: &LmotsAlgorithmType,
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
    public_key: &Sha256Digest,
    signature: &LmotsSignature,
    message: &[u8],
) -> bool {
    let final_result = candidate_ots_signature(algo_type, lms_identifier, q, &signature, &message);

    if final_result != *public_key {
        return false;
    }
    return true;
}

pub fn lms_sign_message(
    algo_type: &LmotsAlgorithmType,
    input_string: &[u8],
    t_tree: &Vec<Sha256Digest>,
    tree_height: u8,
    private_key: &Vec<[u8; 32]>,
    lms_identifier: &LmsIdentifier,
    q: u32,
) -> LmsSignature {
    let q_str = u32str(q);
    let lmots_sig =
        lmots_sign_message(algo_type, input_string, private_key, lms_identifier, &q_str);
    let mut path = vec![];

    let mut node_num = (1 << tree_height) + q;
    let mut sibling = node_num ^ 1;
    path.push(t_tree[sibling as usize]);
    for _ in 1..tree_height {
        node_num = node_num >> 1;
        sibling = node_num ^ 1;
        path.push(t_tree[sibling as usize]);
    }
    let signature = LmsSignature {
        q,
        sig_type: LmsAlgorithmType::LmsSha256N32H10,
        lmots_signature: lmots_sig,
        lms_path: path,
    };
    return signature;
}

pub fn verify_lms_signature(
    tree_height: u8,
    algo_type: &LmotsAlgorithmType,
    input_string: &[u8],
    lms_identifier: &LmsIdentifier,
    q: u32,
    lms_public_key: &Sha256Digest,
    lms_sig: &LmsSignature,
) -> bool {
    let q_str = u32str(q);
    let candidate_key = candidate_ots_signature(
        algo_type,
        lms_identifier,
        &q_str,
        &lms_sig.lmots_signature,
        input_string,
    );
    let mut node_num = (1 << tree_height) + q;
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(u32str(node_num));
    hasher.update(u16str(D_LEAF));
    hasher.update(candidate_key);
    let t_temp = hasher.finalize();
    let mut temp = [0u8; 32];
    for (index, b) in t_temp.iter().enumerate() {
        temp[index] = *b;
    }
    let mut i = 0;
    while node_num > 1 {
        if node_num % 2 == 1 {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(u32str(node_num / 2));
            hasher.update(u16str(D_INTR));
            hasher.update(lms_sig.lms_path[i]);
            hasher.update(temp);
            let t_temp = hasher.finalize();
            for (index, b) in t_temp.iter().enumerate() {
                temp[index] = *b;
            }
        } else {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(u32str(node_num / 2));
            hasher.update(u16str(D_INTR));
            hasher.update(temp);
            hasher.update(lms_sig.lms_path[i]);
            let t_temp = hasher.finalize();
            for (index, b) in t_temp.iter().enumerate() {
                temp[index] = *b;
            }
        }
        node_num = node_num / 2;
        i = i + 1;
    }
    let candidate_key = Sha256Digest::from(temp);
    if candidate_key != *lms_public_key {
        println!("Candidate LMS public key is {:?}", candidate_key);
        println!("The provided LMS key is     {:?}", lms_public_key);
        return false;
    }

    return true;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn lmots_params_test() {
        let result = get_lmots_parameters(&LmotsAlgorithmType::LmotsSha256N32W4);
        assert_eq!(result.n, 32);
    }

    // test case from https://datatracker.ietf.org/doc/html/rfc8554#section-3.1.3
    #[test]
    fn test_coefficient() {
        let input_value = [0x12u8, 0x34u8];
        let result = coefficient(&input_value, 7, 1);
        assert_eq!(result, 0);

        let result = coefficient(&input_value, 0, 4);
        assert_eq!(result, 1);
    }

    #[test]
    fn hss_upper() {
        let _levels = 2;
        let lms_type = 5;
        let lmots_type = 4;
        let identifier: [u8; 16] = [0x61, 0xa5, 0xd5, 0x7d, 0x37, 0xf5, 0xe4, 0x6b, 0xfb, 0x75, 0x20, 0x80, 0x6b, 0x07, 0xa1, 0xb8];
        let hss_public_key = Sha256Digest::from([0x50, 0x65, 0x0e, 0x3b, 0x31, 0xfe, 0x4a, 0x77, 0x3e, 0xa2, 0x9a, 0x07, 0xf0, 0x9c, 0xf2, 0xea, 0x30, 0xe5, 0x79, 0xf0, 0xdf, 0x58, 0xef, 0x8e, 0x29, 0x8d, 0xa0, 0x43, 0x4c, 0xb2, 0xb8, 0x78]);
        let lower_public_hash : [u8; 32] = [0x6c, 0x50, 0x04, 0x91, 0x7d, 0xa6, 0xea, 0xfe, 0x4d, 0x9e, 0xf6, 0xc6, 0x40, 0x7b, 0x3d, 0xb0, 0xe5, 0x48, 0x5b, 0x12, 0x2d, 0x9e, 0xbe, 0x15, 0xcd, 0xa9, 0x3c, 0xfe, 0xc5, 0x82, 0xd7, 0xab];
        let lower_public_identifier: [u8; 16] = [0xd2, 0xf1, 0x4f, 0xf6, 0x34, 0x6a, 0xf9, 0x64, 0x56, 0x9f, 0x7d, 0x6c, 0xb8, 0x80, 0xa1, 0xb6];


        // lms_type, lmots_type, I, k
        let public_buffer :[u8; 56] = [0,0,0,5,  // lms_type
            0,0,0,4, //lmots_type
            //0x61, 0xa5, 0xd5, 0x7d, 0x37, 0xf5, 0xe4, 0x6b, 0xfb, 0x75, 0x20, 0x80, 0x6b, 0x07, 0xa1, 0xb8, // I, aka identifier
            0xd2, 0xf1, 0x4f, 0xf6, 0x34, 0x6a, 0xf9, 0x64, 0x56, 0x9f, 0x7d, 0x6c, 0xb8, 0x80, 0xa1, 0xb6,
            //the hash
            0x6c, 0x50, 0x04, 0x91, 0x7d, 0xa6, 0xea, 0xfe, 0x4d, 0x9e, 0xf6, 0xc6, 0x40, 0x7b, 0x3d, 0xb0, 0xe5, 0x48, 0x5b, 0x12, 0x2d, 0x9e, 0xbe, 0x15, 0xcd, 0xa9, 0x3c, 0xfe, 0xc5, 0x82, 0xd7, 0xab];

        let q = 5;
        let upper_nonce: [u8; 32] = [0xd3, 0x2b, 0x56, 0x67, 0x1d, 0x7e, 0xb9, 0x88, 0x33, 0xc4, 0x9b, 0x43, 0x3c, 0x27, 0x25, 0x86, 0xbc, 0x4a, 0x1c, 0x8a, 0x89, 0x70, 0x52, 0x8f, 0xfa, 0x04, 0xb9, 0x66, 0xf9, 0x42, 0x6e, 0xb9];

        let y: [Sha256Digest; 34] = [Sha256Digest::from([0x96, 0x5a, 0x25, 0xbf, 0xd3, 0x7f, 0x19, 0x6b, 0x90, 0x73, 0xf3, 0xd4, 0xa2, 0x32, 0xfe, 0xb6, 0x91, 0x28, 0xec, 0x45, 0x14, 0x6f, 0x86, 0x29, 0x2f, 0x9d, 0xff, 0x96, 0x10, 0xa7, 0xbf, 0x95]),
            Sha256Digest::from([0xa6, 0x4c, 0x7f, 0x60, 0xf6, 0x26, 0x1a, 0x62, 0x04, 0x3f, 0x86, 0xc7, 0x03, 0x24, 0xb7, 0x70, 0x7f, 0x5b, 0x4a, 0x8a, 0x6e, 0x19, 0xc1, 0x14, 0xc7, 0xbe, 0x86, 0x6d, 0x48, 0x87, 0x78, 0xa0]),
            Sha256Digest::from([0xe0, 0x5f, 0xd5, 0xc6, 0x50, 0x9a, 0x6e, 0x61, 0xd5, 0x59, 0xcf, 0x1a, 0x77, 0xa9, 0x70, 0xde, 0x92, 0x7d, 0x60, 0xc7, 0x0d, 0x3d, 0xe3, 0x1a, 0x7f, 0xa0, 0x10, 0x09, 0x94, 0xe1, 0x62, 0xa2]),
            Sha256Digest::from([0x58, 0x2e, 0x8f, 0xf1, 0xb1, 0x0c, 0xd9, 0x9d, 0x4e, 0x8e, 0x41, 0x3e, 0xf4, 0x69, 0x55, 0x9f, 0x7d, 0x7e, 0xd1, 0x2c, 0x83, 0x83, 0x42, 0xf9, 0xb9, 0xc9, 0x6b, 0x83, 0xa4, 0x94, 0x3d, 0x16]),
            Sha256Digest::from([0x81, 0xd8, 0x4b, 0x15, 0x35, 0x7f, 0xf4, 0x8c, 0xa5, 0x79, 0xf1, 0x9f, 0x5e, 0x71, 0xf1, 0x84, 0x66, 0xf2, 0xbb, 0xef, 0x4b, 0xf6, 0x60, 0xc2, 0x51, 0x8e, 0xb2, 0x0d, 0xe2, 0xf6, 0x6e, 0x3b]),
            Sha256Digest::from([0x14, 0x78, 0x42, 0x69, 0xd7, 0xd8, 0x76, 0xf5, 0xd3, 0x5d, 0x3f, 0xbf, 0xc7, 0x03, 0x9a, 0x46, 0x2c, 0x71, 0x6b, 0xb9, 0xf6, 0x89, 0x1a, 0x7f, 0x41, 0xad, 0x13, 0x3e, 0x9e, 0x1f, 0x6d, 0x95]),
            Sha256Digest::from([0x60, 0xb9, 0x60, 0xe7, 0x77, 0x7c, 0x52, 0xf0, 0x60, 0x49, 0x2f, 0x2d, 0x7c, 0x66, 0x0e, 0x14, 0x71, 0xe0, 0x7e, 0x72, 0x65, 0x55, 0x62, 0x03, 0x5a, 0xbc, 0x9a, 0x70, 0x1b, 0x47, 0x3e, 0xcb]),
            Sha256Digest::from([0xc3, 0x94, 0x3c, 0x6b, 0x9c, 0x4f, 0x24, 0x05, 0xa3, 0xcb, 0x8b, 0xf8, 0xa6, 0x91, 0xca, 0x51, 0xd3, 0xf6, 0xad, 0x2f, 0x42, 0x8b, 0xab, 0x6f, 0x3a, 0x30, 0xf5, 0x5d, 0xd9, 0x62, 0x55, 0x63]),
            Sha256Digest::from([0xf0, 0xa7, 0x5e, 0xe3, 0x90, 0xe3, 0x85, 0xe3, 0xae, 0x0b, 0x90, 0x69, 0x61, 0xec, 0xf4, 0x1a, 0xe0, 0x73, 0xa0, 0x59, 0x0c, 0x2e, 0xb6, 0x20, 0x4f, 0x44, 0x83, 0x1c, 0x26, 0xdd, 0x76, 0x8c]),
            Sha256Digest::from([0x35, 0xb1, 0x67, 0xb2, 0x8c, 0xe8, 0xdc, 0x98, 0x8a, 0x37, 0x48, 0x25, 0x52, 0x30, 0xce, 0xf9, 0x9e, 0xbf, 0x14, 0xe7, 0x30, 0x63, 0x2f, 0x27, 0x41, 0x44, 0x89, 0x80, 0x8a, 0xfa, 0xb1, 0xd1]),
            Sha256Digest::from([0xe7, 0x83, 0xed, 0x04, 0x51, 0x6d, 0xe0, 0x12, 0x49, 0x86, 0x82, 0x21, 0x2b, 0x07, 0x81, 0x05, 0x79, 0xb2, 0x50, 0x36, 0x59, 0x41, 0xbc, 0xc9, 0x81, 0x42, 0xda, 0x13, 0x60, 0x9e, 0x97, 0x68]),
            Sha256Digest::from([0xaa, 0xf6, 0x5d, 0xe7, 0x62, 0x0d, 0xab, 0xec, 0x29, 0xeb, 0x82, 0xa1, 0x7f, 0xde, 0x35, 0xaf, 0x15, 0xad, 0x23, 0x8c, 0x73, 0xf8, 0x1b, 0xdb, 0x8d, 0xec, 0x2f, 0xc0, 0xe7, 0xf9, 0x32, 0x70]),
            Sha256Digest::from([0x10, 0x99, 0x76, 0x2b, 0x37, 0xf4, 0x3c, 0x4a, 0x3c, 0x20, 0x01, 0x0a, 0x3d, 0x72, 0xe2, 0xf6, 0x06, 0xbe, 0x10, 0x8d, 0x31, 0x0e, 0x63, 0x9f, 0x09, 0xce, 0x72, 0x86, 0x80, 0x0d, 0x9e, 0xf8]),
            Sha256Digest::from([0xa1, 0xa4, 0x02, 0x81, 0xcc, 0x5a, 0x7e, 0xa9, 0x8d, 0x2a, 0xdc, 0x7c, 0x74, 0x00, 0xc2, 0xfe, 0x5a, 0x10, 0x15, 0x52, 0xdf, 0x4e, 0x3c, 0xcc, 0xfd, 0x0c, 0xbf, 0x2d, 0xdf, 0x5d, 0xc6, 0x77]),
            Sha256Digest::from([0x9c, 0xbb, 0xc6, 0x8f, 0xee, 0x0c, 0x3e, 0xfe, 0x4e, 0xc2, 0x2b, 0x83, 0xa2, 0xca, 0xa3, 0xe4, 0x8e, 0x08, 0x09, 0xa0, 0xa7, 0x50, 0xb7, 0x3c, 0xcd, 0xcf, 0x3c, 0x79, 0xe6, 0x58, 0x0c, 0x15]),
            Sha256Digest::from([0x4f, 0x8a, 0x58, 0xf7, 0xf2, 0x43, 0x35, 0xee, 0xc5, 0xc5, 0xeb, 0x5e, 0x0c, 0xf0, 0x1d, 0xcf, 0x44, 0x39, 0x42, 0x40, 0x95, 0xfc, 0xeb, 0x07, 0x7f, 0x66, 0xde, 0xd5, 0xbe, 0xc7, 0x3b, 0x27]),
            Sha256Digest::from([0xc5, 0xb9, 0xf6, 0x4a, 0x2a, 0x9a, 0xf2, 0xf0, 0x7c, 0x05, 0xe9, 0x9e, 0x5c, 0xf8, 0x0f, 0x00, 0x25, 0x2e, 0x39, 0xdb, 0x32, 0xf6, 0xc1, 0x96, 0x74, 0xf1, 0x90, 0xc9, 0xfb, 0xc5, 0x06, 0xd8]),
            Sha256Digest::from([0x26, 0x85, 0x77, 0x13, 0xaf, 0xd2, 0xca, 0x6b, 0xb8, 0x5c, 0xd8, 0xc1, 0x07, 0x34, 0x75, 0x52, 0xf3, 0x05, 0x75, 0xa5, 0x41, 0x78, 0x16, 0xab, 0x4d, 0xb3, 0xf6, 0x03, 0xf2, 0xdf, 0x56, 0xfb]),
            Sha256Digest::from([0xc4, 0x13, 0xe7, 0xd0, 0xac, 0xd8, 0xbd, 0xd8, 0x13, 0x52, 0xb2, 0x47, 0x1f, 0xc1, 0xbc, 0x4f, 0x1e, 0xf2, 0x96, 0xfe, 0xa1, 0x22, 0x04, 0x03, 0x46, 0x6b, 0x1a, 0xfe, 0x78, 0xb9, 0x4f, 0x7e]),
            Sha256Digest::from([0xcf, 0x7c, 0xc6, 0x2f, 0xb9, 0x2b, 0xe1, 0x4f, 0x18, 0xc2, 0x19, 0x23, 0x84, 0xeb, 0xce, 0xaf, 0x88, 0x01, 0xaf, 0xdf, 0x94, 0x7f, 0x69, 0x8c, 0xe9, 0xc6, 0xce, 0xb6, 0x96, 0xed, 0x70, 0xe9]),
            Sha256Digest::from([0xe8, 0x7b, 0x01, 0x44, 0x41, 0x7e, 0x8d, 0x7b, 0xaf, 0x25, 0xeb, 0x5f, 0x70, 0xf0, 0x9f, 0x01, 0x6f, 0xc9, 0x25, 0xb4, 0xdb, 0x04, 0x8a, 0xb8, 0xd8, 0xcb, 0x2a, 0x66, 0x1c, 0xe3, 0xb5, 0x7a]),
            Sha256Digest::from([0xda, 0x67, 0x57, 0x1f, 0x5d, 0xd5, 0x46, 0xfc, 0x22, 0xcb, 0x1f, 0x97, 0xe0, 0xeb, 0xd1, 0xa6, 0x59, 0x26, 0xb1, 0x23, 0x4f, 0xd0, 0x4f, 0x17, 0x1c, 0xf4, 0x69, 0xc7, 0x6b, 0x88, 0x4c, 0xf3]),
            Sha256Digest::from([0x11, 0x5c, 0xce, 0x6f, 0x79, 0x2c, 0xc8, 0x4e, 0x36, 0xda, 0x58, 0x96, 0x0c, 0x5f, 0x1d, 0x76, 0x0f, 0x32, 0xc1, 0x2f, 0xae, 0xf4, 0x77, 0xe9, 0x4c, 0x92, 0xeb, 0x75, 0x62, 0x5b, 0x6a, 0x37]),
            Sha256Digest::from([0x1e, 0xfc, 0x72, 0xd6, 0x0c, 0xa5, 0xe9, 0x08, 0xb3, 0xa7, 0xdd, 0x69, 0xfe, 0xf0, 0x24, 0x91, 0x50, 0xe3, 0xee, 0xbd, 0xfe, 0xd3, 0x9c, 0xbd, 0xc3, 0xce, 0x97, 0x04, 0x88, 0x2a, 0x20, 0x72]),
            Sha256Digest::from([0xc7, 0x5e, 0x13, 0x52, 0x7b, 0x7a, 0x58, 0x1a, 0x55, 0x61, 0x68, 0x78, 0x3d, 0xc1, 0xe9, 0x75, 0x45, 0xe3, 0x18, 0x65, 0xdd, 0xc4, 0x6b, 0x3c, 0x95, 0x78, 0x35, 0xda, 0x25, 0x2b, 0xb7, 0x32]),
            Sha256Digest::from([0x8d, 0x3e, 0xe2, 0x06, 0x24, 0x45, 0xdf, 0xb8, 0x5e, 0xf8, 0xc3, 0x5f, 0x8e, 0x1f, 0x33, 0x71, 0xaf, 0x34, 0x02, 0x3c, 0xef, 0x62, 0x6e, 0x0a, 0xf1, 0xe0, 0xbc, 0x01, 0x73, 0x51, 0xaa, 0xe2]),
            Sha256Digest::from([0xab, 0x8f, 0x5c, 0x61, 0x2e, 0xad, 0x0b, 0x72, 0x9a, 0x1d, 0x05, 0x9d, 0x02, 0xbf, 0xe1, 0x8e, 0xfa, 0x97, 0x1b, 0x73, 0x00, 0xe8, 0x82, 0x36, 0x0a, 0x93, 0xb0, 0x25, 0xff, 0x97, 0xe9, 0xe0]),
            Sha256Digest::from([0xee, 0xc0, 0xf3, 0xf3, 0xf1, 0x30, 0x39, 0xa1, 0x7f, 0x88, 0xb0, 0xcf, 0x80, 0x8f, 0x48, 0x84, 0x31, 0x60, 0x6c, 0xb1, 0x3f, 0x92, 0x41, 0xf4, 0x0f, 0x44, 0xe5, 0x37, 0xd3, 0x02, 0xc6, 0x4a]),
            Sha256Digest::from([0x4f, 0x1f, 0x4a, 0xb9, 0x49, 0xb9, 0xfe, 0xef, 0xad, 0xcb, 0x71, 0xab, 0x50, 0xef, 0x27, 0xd6, 0xd6, 0xca, 0x85, 0x10, 0xf1, 0x50, 0xc8, 0x5f, 0xb5, 0x25, 0xbf, 0x25, 0x70, 0x3d, 0xf7, 0x20]),
            Sha256Digest::from([0x9b, 0x60, 0x66, 0xf0, 0x9c, 0x37, 0x28, 0x0d, 0x59, 0x12, 0x8d, 0x2f, 0x0f, 0x63, 0x7c, 0x7d, 0x7d, 0x7f, 0xad, 0x4e, 0xd1, 0xc1, 0xea, 0x04, 0xe6, 0x28, 0xd2, 0x21, 0xe3, 0xd8, 0xdb, 0x77]),
            Sha256Digest::from([0xb7, 0xc8, 0x78, 0xc9, 0x41, 0x1c, 0xaf, 0xc5, 0x07, 0x1a, 0x34, 0xa0, 0x0f, 0x4c, 0xf0, 0x77, 0x38, 0x91, 0x27, 0x53, 0xdf, 0xce, 0x48, 0xf0, 0x75, 0x76, 0xf0, 0xd4, 0xf9, 0x4f, 0x42, 0xc6]),
            Sha256Digest::from([0xd7, 0x6f, 0x7c, 0xe9, 0x73, 0xe9, 0x36, 0x70, 0x95, 0xba, 0x7e, 0x9a, 0x36, 0x49, 0xb7, 0xf4, 0x61, 0xd9, 0xf9, 0xac, 0x13, 0x32, 0xa4, 0xd1, 0x04, 0x4c, 0x96, 0xae, 0xfe, 0xe6, 0x76, 0x76]),
            Sha256Digest::from([0x40, 0x1b, 0x64, 0x45, 0x7c, 0x54, 0xd6, 0x5f, 0xef, 0x65, 0x00, 0xc5, 0x9c, 0xdf, 0xb6, 0x9a, 0xf7, 0xb6, 0xdd, 0xdf, 0xcb, 0x0f, 0x08, 0x62, 0x78, 0xdd, 0x8a, 0xd0, 0x68, 0x60, 0x78, 0xdf]),
            Sha256Digest::from([0xb0, 0xf3, 0xf7, 0x9c, 0xd8, 0x93, 0xd3, 0x14, 0x16, 0x86, 0x48, 0x49, 0x98, 0x98, 0xfb, 0xc0, 0xce, 0xd5, 0xf9, 0x5b, 0x74, 0xe8, 0xff, 0x14, 0xd7, 0x35, 0xcd, 0xea, 0x96, 0x8b, 0xee, 0x74])
        ];
        let path: [Sha256Digest; 5] = [
            Sha256Digest::from([0xd8, 0xb8, 0x11, 0x2f, 0x92, 0x00, 0xa5, 0xe5, 0x0c, 0x4a, 0x26, 0x21, 0x65, 0xbd, 0x34, 0x2c, 0xd8, 0x00, 0xb8, 0x49, 0x68, 0x10, 0xbc, 0x71, 0x62, 0x77, 0x43, 0x5a, 0xc3, 0x76, 0x72, 0x8d]),
            Sha256Digest::from([0x12, 0x9a, 0xc6, 0xed, 0xa8, 0x39, 0xa6, 0xf3, 0x57, 0xb5, 0xa0, 0x43, 0x87, 0xc5, 0xce, 0x97, 0x38, 0x2a, 0x78, 0xf2, 0xa4, 0x37, 0x29, 0x17, 0xee, 0xfc, 0xbf, 0x93, 0xf6, 0x3b, 0xb5, 0x91]),
            Sha256Digest::from([0x12, 0xf5, 0xdb, 0xe4, 0x00, 0xbd, 0x49, 0xe4, 0x50, 0x1e, 0x85, 0x9f, 0x88, 0x5b, 0xf0, 0x73, 0x6e, 0x90, 0xa5, 0x09, 0xb3, 0x0a, 0x26, 0xbf, 0xac, 0x8c, 0x17, 0xb5, 0x99, 0x1c, 0x15, 0x7e]),
            Sha256Digest::from([0xb5, 0x97, 0x11, 0x15, 0xaa, 0x39, 0xef, 0xd8, 0xd5, 0x64, 0xa6, 0xb9, 0x02, 0x82, 0xc3, 0x16, 0x8a, 0xf2, 0xd3, 0x0e, 0xf8, 0x9d, 0x51, 0xbf, 0x14, 0x65, 0x45, 0x10, 0xa1, 0x2b, 0x8a, 0x14]),
            Sha256Digest::from([0x4c, 0xca, 0x18, 0x48, 0xcf, 0x7d, 0xa5, 0x9c, 0xc2, 0xb3, 0xd9, 0xd0, 0x69, 0x2d, 0xd2, 0xa2, 0x0b, 0xa3, 0x86, 0x34, 0x80, 0xe2, 0x5b, 0x1b, 0x85, 0xee, 0x86, 0x0c, 0x62, 0xbf, 0x51, 0x36])
        ];

        let upper_ots = LmotsSignature{
            ots_type: LmotsAlgorithmType::LmotsSha256N32W8,
            nonce: upper_nonce,
            y: Vec::from(y),
        };

        let upper_signature = LmsSignature{
            q,
            lmots_signature: upper_ots,
            sig_type: LmsAlgorithmType::LmsSha256N32H5,
            lms_path: Vec::from(path),
        };

        let success = verify_lms_signature(5, &LmotsAlgorithmType::LmotsSha256N32W8, &public_buffer, &identifier, q, &hss_public_key, &upper_signature);
        println!("Did upper pass? {}", success);
        assert_eq!(success, true);

    }

    #[test]
    fn lms_lower() {
        let message: [u8; 162] = [0x54, 0x68, 0x65, 0x20, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x64, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
            0x55, 0x6e, 0x69, 0x74, 0x65, 0x64, 0x20, 0x53, 0x74, 0x61, 0x74, 0x65, 0x73, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x69, 0x6f,
            0x6e, 0x2c, 0x20, 0x6e, 0x6f, 0x72, 0x20, 0x70, 0x72, 0x6f, 0x68, 0x69, 0x62, 0x69, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x69, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53,
            0x74, 0x61, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x74, 0x61, 0x74, 0x65,
            0x73, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6c, 0x79, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x65, 0x6f, 0x70, 0x6c, 0x65, 0x2e, 0x0a];
        let lms_public_identifier: [u8; 16] = [0xd2, 0xf1, 0x4f, 0xf6, 0x34, 0x6a, 0xf9, 0x64, 0x56, 0x9f, 0x7d, 0x6c, 0xb8, 0x80, 0xa1, 0xb6];

        let lms_public_key = Sha256Digest::from([0x6c, 0x50, 0x04, 0x91, 0x7d, 0xa6, 0xea, 0xfe, 0x4d, 0x9e, 0xf6, 0xc6, 0x40, 0x7b, 0x3d, 0xb0, 0xe5, 0x48, 0x5b, 0x12, 0x2d, 0x9e, 0xbe, 0x15, 0xcd, 0xa9, 0x3c, 0xfe, 0xc5, 0x82, 0xd7, 0xab]);

        // final signature
        let lms_q = 0xa;
        let final_c: [u8; 32] = [0x07, 0x03, 0xc4, 0x91, 0xe7, 0x55, 0x8b, 0x35, 0x01, 0x1e, 0xce, 0x35, 0x92, 0xea, 0xa5, 0xda, 0x4d, 0x91, 0x87, 0x86, 0x77, 0x12, 0x33, 0xe8, 0x35, 0x3b, 0xc4, 0xf6, 0x23, 0x23, 0x18, 0x5c];
        let final_y: [Sha256Digest; 34] = [Sha256Digest::from([0x95, 0xca, 0xe0, 0x5b, 0x89, 0x9e, 0x35, 0xdf, 0xfd, 0x71, 0x70, 0x54, 0x70, 0x62, 0x09, 0x98, 0x8e, 0xbf, 0xdf, 0x6e, 0x37, 0x96, 0x0b, 0xb5, 0xc3, 0x8d, 0x76, 0x57, 0xe8, 0xbf, 0xfe, 0xef]),
        Sha256Digest::from([0x9b, 0xc0, 0x42, 0xda, 0x4b, 0x45, 0x25, 0x65, 0x04, 0x85, 0xc6, 0x6d, 0x0c, 0xe1, 0x9b, 0x31, 0x75, 0x87, 0xc6, 0xba, 0x4b, 0xff, 0xcc, 0x42, 0x8e, 0x25, 0xd0, 0x89, 0x31, 0xe7, 0x2d, 0xfb]),
        Sha256Digest::from([0x6a, 0x12, 0x0c, 0x56, 0x12, 0x34, 0x42, 0x58, 0xb8, 0x5e, 0xfd, 0xb7, 0xdb, 0x1d, 0xb9, 0xe1, 0x86, 0x5a, 0x73, 0xca, 0xf9, 0x65, 0x57, 0xeb, 0x39, 0xed, 0x3e, 0x3f, 0x42, 0x69, 0x33, 0xac]),
        Sha256Digest::from([0x9e, 0xed, 0xdb, 0x03, 0xa1, 0xd2, 0x37, 0x4a, 0xf7, 0xbf, 0x77, 0x18, 0x55, 0x77, 0x45, 0x62, 0x37, 0xf9, 0xde, 0x2d, 0x60, 0x11, 0x3c, 0x23, 0xf8, 0x46, 0xdf, 0x26, 0xfa, 0x94, 0x20, 0x08]),
        Sha256Digest::from([0xa6, 0x98, 0x99, 0x4c, 0x08, 0x27, 0xd9, 0x0e, 0x86, 0xd4, 0x3e, 0x0d, 0xf7, 0xf4, 0xbf, 0xcd, 0xb0, 0x9b, 0x86, 0xa3, 0x73, 0xb9, 0x82, 0x88, 0xb7, 0x09, 0x4a, 0xd8, 0x1a, 0x01, 0x85, 0xac]),
        Sha256Digest::from([0x10, 0x0e, 0x4f, 0x2c, 0x5f, 0xc3, 0x8c, 0x00, 0x3c, 0x1a, 0xb6, 0xfe, 0xa4, 0x79, 0xeb, 0x2f, 0x5e, 0xbe, 0x48, 0xf5, 0x84, 0xd7, 0x15, 0x9b, 0x8a, 0xda, 0x03, 0x58, 0x6e, 0x65, 0xad, 0x9c]),
        Sha256Digest::from([0x96, 0x9f, 0x6a, 0xec, 0xbf, 0xe4, 0x4c, 0xf3, 0x56, 0x88, 0x8a, 0x7b, 0x15, 0xa3, 0xff, 0x07, 0x4f, 0x77, 0x17, 0x60, 0xb2, 0x6f, 0x9c, 0x04, 0x88, 0x4e, 0xe1, 0xfa, 0xa3, 0x29, 0xfb, 0xf4]),
        Sha256Digest::from([0xe6, 0x1a, 0xf2, 0x3a, 0xee, 0x7f, 0xa5, 0xd4, 0xd9, 0xa5, 0xdf, 0xcf, 0x43, 0xc4, 0xc2, 0x6c, 0xe8, 0xae, 0xa2, 0xce, 0x8a, 0x29, 0x90, 0xd7, 0xba, 0x7b, 0x57, 0x10, 0x8b, 0x47, 0xda, 0xbf]),
        Sha256Digest::from([0xbe, 0xad, 0xb2, 0xb2, 0x5b, 0x3c, 0xac, 0xc1, 0xac, 0x0c, 0xef, 0x34, 0x6c, 0xbb, 0x90, 0xfb, 0x04, 0x4b, 0xee, 0xe4, 0xfa, 0xc2, 0x60, 0x3a, 0x44, 0x2b, 0xdf, 0x7e, 0x50, 0x72, 0x43, 0xb7]),
        Sha256Digest::from([0x31, 0x9c, 0x99, 0x44, 0xb1, 0x58, 0x6e, 0x89, 0x9d, 0x43, 0x1c, 0x7f, 0x91, 0xbc, 0xcc, 0xc8, 0x69, 0x0d, 0xbf, 0x59, 0xb2, 0x83, 0x86, 0xb2, 0x31, 0x5f, 0x3d, 0x36, 0xef, 0x2e, 0xaa, 0x3c]),
        Sha256Digest::from([0xf3, 0x0b, 0x2b, 0x51, 0xf4, 0x8b, 0x71, 0xb0, 0x03, 0xdf, 0xb0, 0x82, 0x49, 0x48, 0x42, 0x01, 0x04, 0x3f, 0x65, 0xf5, 0xa3, 0xef, 0x6b, 0xbd, 0x61, 0xdd, 0xfe, 0xe8, 0x1a, 0xca, 0x9c, 0xe6]),
        Sha256Digest::from([0x00, 0x81, 0x26, 0x2a, 0x00, 0x00, 0x04, 0x80, 0xdc, 0xbc, 0x9a, 0x3d, 0xa6, 0xfb, 0xef, 0x5c, 0x1c, 0x0a, 0x55, 0xe4, 0x8a, 0x0e, 0x72, 0x9f, 0x91, 0x84, 0xfc, 0xb1, 0x40, 0x7c, 0x31, 0x52]),
        Sha256Digest::from([0x9d, 0xb2, 0x68, 0xf6, 0xfe, 0x50, 0x03, 0x2a, 0x36, 0x3c, 0x98, 0x01, 0x30, 0x68, 0x37, 0xfa, 0xfa, 0xbd, 0xf9, 0x57, 0xfd, 0x97, 0xea, 0xfc, 0x80, 0xdb, 0xd1, 0x65, 0xe4, 0x35, 0xd0, 0xe2]),
        Sha256Digest::from([0xdf, 0xd8, 0x36, 0xa2, 0x8b, 0x35, 0x40, 0x23, 0x92, 0x4b, 0x6f, 0xb7, 0xe4, 0x8b, 0xc0, 0xb3, 0xed, 0x95, 0xee, 0xa6, 0x4c, 0x2d, 0x40, 0x2f, 0x4d, 0x73, 0x4c, 0x8d, 0xc2, 0x6f, 0x3a, 0xc5]),
        Sha256Digest::from([0x91, 0x82, 0x5d, 0xae, 0xf0, 0x1e, 0xae, 0x3c, 0x38, 0xe3, 0x32, 0x8d, 0x00, 0xa7, 0x7d, 0xc6, 0x57, 0x03, 0x4f, 0x28, 0x7c, 0xcb, 0x0f, 0x0e, 0x1c, 0x9a, 0x7c, 0xbd, 0xc8, 0x28, 0xf6, 0x27]),
        Sha256Digest::from([0x20, 0x5e, 0x47, 0x37, 0xb8, 0x4b, 0x58, 0x37, 0x65, 0x51, 0xd4, 0x4c, 0x12, 0xc3, 0xc2, 0x15, 0xc8, 0x12, 0xa0, 0x97, 0x07, 0x89, 0xc8, 0x3d, 0xe5, 0x1d, 0x6a, 0xd7, 0x87, 0x27, 0x19, 0x63]),
        Sha256Digest::from([0x32, 0x7f, 0x0a, 0x5f, 0xbb, 0x6b, 0x59, 0x07, 0xde, 0xc0, 0x2c, 0x9a, 0x90, 0x93, 0x4a, 0xf5, 0xa1, 0xc6, 0x3b, 0x72, 0xc8, 0x26, 0x53, 0x60, 0x5d, 0x1d, 0xcc, 0xe5, 0x15, 0x96, 0xb3, 0xc2]),
        Sha256Digest::from([0xb4, 0x56, 0x96, 0x68, 0x9f, 0x2e, 0xb3, 0x82, 0x00, 0x74, 0x97, 0x55, 0x76, 0x92, 0xca, 0xac, 0x4d, 0x57, 0xb5, 0xde, 0x9f, 0x55, 0x69, 0xbc, 0x2a, 0xd0, 0x13, 0x7f, 0xd4, 0x7f, 0xb4, 0x7e]),
        Sha256Digest::from([0x66, 0x4f, 0xcb, 0x6d, 0xb4, 0x97, 0x1f, 0x5b, 0x3e, 0x07, 0xac, 0xed, 0xa9, 0xac, 0x13, 0x0e, 0x9f, 0x38, 0x18, 0x2d, 0xe9, 0x94, 0xcf, 0xf1, 0x92, 0xec, 0x0e, 0x82, 0xfd, 0x6d, 0x4c, 0xb7]),
        Sha256Digest::from([0xf3, 0xfe, 0x00, 0x81, 0x25, 0x89, 0xb7, 0xa7, 0xce, 0x51, 0x54, 0x40, 0x45, 0x64, 0x33, 0x01, 0x6b, 0x84, 0xa5, 0x9b, 0xec, 0x66, 0x19, 0xa1, 0xc6, 0xc0, 0xb3, 0x7d, 0xd1, 0x45, 0x0e, 0xd4]),
        Sha256Digest::from([0xf2, 0xd8, 0xb5, 0x84, 0x41, 0x0c, 0xed, 0xa8, 0x02, 0x5f, 0x5d, 0x2d, 0x8d, 0xd0, 0xd2, 0x17, 0x6f, 0xc1, 0xcf, 0x2c, 0xc0, 0x6f, 0xa8, 0xc8, 0x2b, 0xed, 0x4d, 0x94, 0x4e, 0x71, 0x33, 0x9e]),
        Sha256Digest::from([0xce, 0x78, 0x0f, 0xd0, 0x25, 0xbd, 0x41, 0xec, 0x34, 0xeb, 0xff, 0x9d, 0x42, 0x70, 0xa3, 0x22, 0x4e, 0x01, 0x9f, 0xcb, 0x44, 0x44, 0x74, 0xd4, 0x82, 0xfd, 0x2d, 0xbe, 0x75, 0xef, 0xb2, 0x03]),
        Sha256Digest::from([0x89, 0xcc, 0x10, 0xcd, 0x60, 0x0a, 0xbb, 0x54, 0xc4, 0x7e, 0xde, 0x93, 0xe0, 0x8c, 0x11, 0x4e, 0xdb, 0x04, 0x11, 0x7d, 0x71, 0x4d, 0xc1, 0xd5, 0x25, 0xe1, 0x1b, 0xed, 0x87, 0x56, 0x19, 0x2f]),
        Sha256Digest::from([0x92, 0x9d, 0x15, 0x46, 0x2b, 0x93, 0x9f, 0xf3, 0xf5, 0x2f, 0x22, 0x52, 0xda, 0x2e, 0xd6, 0x4d, 0x8f, 0xae, 0x88, 0x81, 0x8b, 0x1e, 0xfa, 0x2c, 0x7b, 0x08, 0xc8, 0x79, 0x4f, 0xb1, 0xb2, 0x14]),
        Sha256Digest::from([0xaa, 0x23, 0x3d, 0xb3, 0x16, 0x28, 0x33, 0x14, 0x1e, 0xa4, 0x38, 0x3f, 0x1a, 0x6f, 0x12, 0x0b, 0xe1, 0xdb, 0x82, 0xce, 0x36, 0x30, 0xb3, 0x42, 0x91, 0x14, 0x46, 0x31, 0x57, 0xa6, 0x4e, 0x91]),
        Sha256Digest::from([0x23, 0x4d, 0x47, 0x5e, 0x2f, 0x79, 0xcb, 0xf0, 0x5e, 0x4d, 0xb6, 0xa9, 0x40, 0x7d, 0x72, 0xc6, 0xbf, 0xf7, 0xd1, 0x19, 0x8b, 0x5c, 0x4d, 0x6a, 0xad, 0x28, 0x31, 0xdb, 0x61, 0x27, 0x49, 0x93]),
        Sha256Digest::from([0x71, 0x5a, 0x01, 0x82, 0xc7, 0xdc, 0x80, 0x89, 0xe3, 0x2c, 0x85, 0x31, 0xde, 0xed, 0x4f, 0x74, 0x31, 0xc0, 0x7c, 0x02, 0x19, 0x5e, 0xba, 0x2e, 0xf9, 0x1e, 0xfb, 0x56, 0x13, 0xc3, 0x7a, 0xf7]),
        Sha256Digest::from([0xae, 0x0c, 0x06, 0x6b, 0xab, 0xc6, 0x93, 0x69, 0x70, 0x0e, 0x1d, 0xd2, 0x6e, 0xdd, 0xc0, 0xd2, 0x16, 0xc7, 0x81, 0xd5, 0x6e, 0x4c, 0xe4, 0x7e, 0x33, 0x03, 0xfa, 0x73, 0x00, 0x7f, 0xf7, 0xb9]),
        Sha256Digest::from([0x49, 0xef, 0x23, 0xbe, 0x2a, 0xa4, 0xdb, 0xf2, 0x52, 0x06, 0xfe, 0x45, 0xc2, 0x0d, 0xd8, 0x88, 0x39, 0x5b, 0x25, 0x26, 0x39, 0x1a, 0x72, 0x49, 0x96, 0xa4, 0x41, 0x56, 0xbe, 0xac, 0x80, 0x82]),
        Sha256Digest::from([0x12, 0x85, 0x87, 0x92, 0xbf, 0x8e, 0x74, 0xcb, 0xa4, 0x9d, 0xee, 0x5e, 0x88, 0x12, 0xe0, 0x19, 0xda, 0x87, 0x45, 0x4b, 0xff, 0x9e, 0x84, 0x7e, 0xd8, 0x3d, 0xb0, 0x7a, 0xf3, 0x13, 0x74, 0x30]),
        Sha256Digest::from([0x82, 0xf8, 0x80, 0xa2, 0x78, 0xf6, 0x82, 0xc2, 0xbd, 0x0a, 0xd6, 0x88, 0x7c, 0xb5, 0x9f, 0x65, 0x2e, 0x15, 0x59, 0x87, 0xd6, 0x1b, 0xbf, 0x6a, 0x88, 0xd3, 0x6e, 0xe9, 0x3b, 0x60, 0x72, 0xe6]),
        Sha256Digest::from([0x65, 0x6d, 0x9c, 0xcb, 0xaa, 0xe3, 0xd6, 0x55, 0x85, 0x2e, 0x38, 0xde, 0xb3, 0xa2, 0xdc, 0xf8, 0x05, 0x8d, 0xc9, 0xfb, 0x6f, 0x2a, 0xb3, 0xd3, 0xb3, 0x53, 0x9e, 0xb7, 0x7b, 0x24, 0x8a, 0x66]),
        Sha256Digest::from([0x10, 0x91, 0xd0, 0x5e, 0xb6, 0xe2, 0xf2, 0x97, 0x77, 0x4f, 0xe6, 0x05, 0x35, 0x98, 0x45, 0x7c, 0xc6, 0x19, 0x08, 0x31, 0x8d, 0xe4, 0xb8, 0x26, 0xf0, 0xfc, 0x86, 0xd4, 0xbb, 0x11, 0x7d, 0x33]),
        Sha256Digest::from([0xe8, 0x65, 0xaa, 0x80, 0x50, 0x09, 0xcc, 0x29, 0x18, 0xd9, 0xc2, 0xf8, 0x40, 0xc4, 0xda, 0x43, 0xa7, 0x03, 0xad, 0x9f, 0x5b, 0x58, 0x06, 0x16, 0x3d, 0x71, 0x61, 0x69, 0x6b, 0x5a, 0x0a, 0xdc])
        ];

        let final_path : [Sha256Digest; 5] = [Sha256Digest::from([0xd5, 0xc0, 0xd1, 0xbe, 0xbb, 0x06, 0x04, 0x8e, 0xd6, 0xfe, 0x2e, 0xf2, 0xc6, 0xce, 0xf3, 0x05, 0xb3, 0xed, 0x63, 0x39, 0x41, 0xeb, 0xc8, 0xb3, 0xbe, 0xc9, 0x73, 0x87, 0x54, 0xcd, 0xdd, 0x60]),
            Sha256Digest::from([0xe1, 0x92, 0x0a, 0xda, 0x52, 0xf4, 0x3d, 0x05, 0x5b, 0x50, 0x31, 0xce, 0xe6, 0x19, 0x25, 0x20, 0xd6, 0xa5, 0x11, 0x55, 0x14, 0x85, 0x1c, 0xe7, 0xfd, 0x44, 0x8d, 0x4a, 0x39, 0xfa, 0xe2, 0xab]),
            Sha256Digest::from([0x23, 0x35, 0xb5, 0x25, 0xf4, 0x84, 0xe9, 0xb4, 0x0d, 0x6a, 0x4a, 0x96, 0x93, 0x94, 0x84, 0x3b, 0xdc, 0xf6, 0xd1, 0x4c, 0x48, 0xe8, 0x01, 0x5e, 0x08, 0xab, 0x92, 0x66, 0x2c, 0x05, 0xc6, 0xe9]),
            Sha256Digest::from([0xf9, 0x0b, 0x65, 0xa7, 0xa6, 0x20, 0x16, 0x89, 0x99, 0x9f, 0x32, 0xbf, 0xd3, 0x68, 0xe5, 0xe3, 0xec, 0x9c, 0xb7, 0x0a, 0xc7, 0xb8, 0x39, 0x90, 0x03, 0xf1, 0x75, 0xc4, 0x08, 0x85, 0x08, 0x1a]),
            Sha256Digest::from([0x09, 0xab, 0x30, 0x34, 0x91, 0x1f, 0xe1, 0x25, 0x63, 0x10, 0x51, 0xdf, 0x04, 0x08, 0xb3, 0x94, 0x6b, 0x0b, 0xde, 0x79, 0x09, 0x11, 0xe8, 0x97, 0x8b, 0xa0, 0x7d, 0xd5, 0x6c, 0x73, 0xe7, 0xee])
        ];


        let final_ots_sig = LmotsSignature{ ots_type: LmotsAlgorithmType::LmotsSha256N32W8,
            nonce: final_c,
            y: Vec::from(final_y)
        };

        let final_lms_sig = LmsSignature{
            q: lms_q,
            lmots_signature: final_ots_sig,
            sig_type: LmsAlgorithmType::LmsSha256N32H5,
            lms_path: Vec::from(final_path)
        };


        let final_thingie = verify_lms_signature(5, &LmotsAlgorithmType::LmotsSha256N32W8, &message, &lms_public_identifier, lms_q, &lms_public_key, &final_lms_sig);
        assert_eq!(final_thingie, true);
        println!("Final thingie is {}", final_thingie);


    }
}
