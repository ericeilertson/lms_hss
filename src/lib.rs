use byteorder::{BigEndian, ByteOrder};
use rand::random;
use sha2::{Digest, Sha256};
use std::hash::Hash;

#[macro_use]
extern crate enum_primitive;
extern crate num;
use num::FromPrimitive;

const D_PBLC: u16 = 0x8080;
const D_MESG: u16 = 0x8181;
const D_LEAF: u16 = 0x8282;
const D_INTR: u16 = 0x8383;

type LMSResult<T> = Result<T, String>;

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct HashValue<const N: usize>([u8; N]);

impl<const N: usize> Default for HashValue<N> {
    fn default() -> Self {
        let data = [0u8; N];
        HashValue(data)
    }
}

impl<const N: usize> From<[u8; N]> for HashValue<N> {
    fn from(data: [u8; N]) -> Self {
        HashValue(data)
    }
}

impl From<[u8; 32]> for HashValue<24> {
    fn from(data: [u8; 32]) -> Self {
        let mut t = [0u8; 24];
        t[..24].copy_from_slice(&data[..24]);
        HashValue(t)
    }
}

impl<const N: usize> AsRef<[u8]> for HashValue<N> {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

pub type Sha256Digest = HashValue<32>;
pub type Sha192Digest = HashValue<24>;
pub type LmsIdentifier = [u8; 16];

enum_from_primitive! {
#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum LmotsAlgorithmType {
    LmotsReserved = 0,
    LmotsSha256N32W1 = 1,
    LmotsSha256N32W2 = 2,
    LmotsSha256N32W4 = 3,
    LmotsSha256N32W8 = 4,
    LmotsSha256N24W1 = 5,
    LmotsSha256N24W2 = 6,
    LmotsSha256N24W4 = 7,
    LmotsSha256N24W8 = 8,
}
}
pub fn lookup_lmots_algorithm_type(val: u32) -> Option<LmotsAlgorithmType> {
    LmotsAlgorithmType::from_u32(val)
}

enum_from_primitive! {
#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum LmsAlgorithmType {
    LmsReserved = 0,
    LmsSha256N32H5 = 5,
    LmsSha256N32H10 = 6,
    LmsSha256N32H15 = 7,
    LmsSha256N32H20 = 8,
    LmsSha256N32H25 = 9,
    LmsSha256N24H5 = 10,
    LmsSha256N24H10 = 11,
    LmsSha256N24H15 = 12,
    LmsSha256N24H20 = 13,
    LmsSha256N24H25 = 14,
}
}

pub fn lookup_lms_algorithm_type(val: u32) -> Option<LmsAlgorithmType> {
    LmsAlgorithmType::from_u32(val)
}

#[derive(Debug)]
pub struct LmotsSignature<const N: usize, const P: usize> {
    pub ots_type: LmotsAlgorithmType,
    pub nonce: [u8; N],
    pub y: [HashValue<N>; P],
}

#[derive(Debug)]
pub struct LmsSignature<const N: usize, const P: usize> {
    pub q: u32,
    pub lmots_signature: LmotsSignature<N, P>,
    pub sig_type: LmsAlgorithmType,
    pub lms_path: Vec<HashValue<N>>,
}

#[derive(Debug)]
pub struct LmotsParameter {
    pub algorithm_name: LmotsAlgorithmType,
    pub n: u8,
    pub w: u8,
    pub p: u16,
    pub ls: u8,
}

const LMOTS_P: [LmotsParameter; 9] = [
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsReserved,
        n: 0,
        w: 0,
        p: 0,
        ls: 0,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W1,
        n: 32,
        w: 1,
        p: 265,
        ls: 7,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W2,
        n: 32,
        w: 2,
        p: 133,
        ls: 6,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W4,
        n: 32,
        w: 4,
        p: 67,
        ls: 4,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N32W8,
        n: 32,
        w: 8,
        p: 34,
        ls: 0,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W1,
        n: 24,
        w: 1,
        p: 200,
        ls: 8,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W2,
        n: 24,
        w: 2,
        p: 101,
        ls: 6,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W4,
        n: 24,
        w: 4,
        p: 51,
        ls: 4,
    },
    LmotsParameter {
        algorithm_name: LmotsAlgorithmType::LmotsSha256N24W8,
        n: 24,
        w: 8,
        p: 26,
        ls: 0,
    },
];

//do we actually need these?
fn u32str(i: u32) -> [u8; 4] {
    let mut buf = [0; 4];
    BigEndian::write_u32(&mut buf, i);
    buf
}

fn u16str(i: u16) -> [u8; 2] {
    let mut buf = [0; 2];
    BigEndian::write_u16(&mut buf, i);
    buf
}

fn u8str(i: u8) -> [u8; 1] {
    let mut buf = [0; 1];
    buf[0] = i;
    buf
}

pub fn get_lmots_parameters(algo_type: &LmotsAlgorithmType) -> &'static LmotsParameter {
    for i in &LMOTS_P {
        if i.algorithm_name == *algo_type {
            return i;
        }
    }
    panic!("Its all screwed")
}

pub fn get_lms_parameters(algo_type: &LmsAlgorithmType) -> (u8, u8) {
    match algo_type {
        LmsAlgorithmType::LmsSha256N32H5 => (32, 5),
        LmsAlgorithmType::LmsSha256N32H10 => (32, 10),
        LmsAlgorithmType::LmsSha256N32H15 => (32, 15),
        LmsAlgorithmType::LmsSha256N32H20 => (32, 20),
        LmsAlgorithmType::LmsSha256N32H25 => (32, 25),
        LmsAlgorithmType::LmsSha256N24H5 => (24, 5),
        LmsAlgorithmType::LmsSha256N24H10 => (24, 10),
        LmsAlgorithmType::LmsSha256N24H15 => (24, 15),
        LmsAlgorithmType::LmsSha256N24H20 => (24, 20),
        LmsAlgorithmType::LmsSha256N24H25 => (24, 25),
        LmsAlgorithmType::LmsReserved => {
            panic!("Its all screwed")
        }
    }
}

// follows pseudo code at https://www.rfc-editor.org/rfc/rfc8554#section-3.1.3
fn coefficient(s: &[u8], i: usize, w: usize) -> u8 {
    let blah: u16 = (1 << (w)) - 1;
    let index = i * w / 8;
    let b = s[index];

    // extra logic to avoid the divide by 0
    // which a good compiler would notice only happens when w is 0 and that portion of the
    // expression could be skipped
    let mut shift = 8;
    if w != 0 {
        shift = 8 - (w * (i % (8 / w)) + w);
    }

    // Rust errors if we try to shift off all of the bits off from a value
    // some implementations 0 fill, others do some other filling.
    // we make this be 0
    let mut rs = 0;
    if shift < 8 {
        rs = b >> shift;
    }
    let small_blah = blah as u8;
    small_blah & rs
}

fn create_lmots_private_key<const N: usize, const P: usize>(
    algo_type: &LmotsAlgorithmType,
) -> LMSResult<[HashValue<N>; P]> {
    let params = get_lmots_parameters(algo_type);
    assert_eq!(params.p as usize, P);
    let mut x = [HashValue::<N>::default(); P];
    if N > 32 {
        return Err("Error generating private key, currently defined for a max of 32 bytes".to_string());
    }
    for index in 0..P {
        let ttmp: [u8; 32] = random(); // generate 32 bytes, the from will copy only the portion we need
        let mut tmp: [u8; N] = [0u8; N];
        tmp[..N].copy_from_slice(&ttmp[..N]);
        x[index] = HashValue::<N>::from(tmp);
    }
    Ok(x)
}

fn calculate_ots_public_key<const N: usize, const P: usize>(
    algo_type: &LmotsAlgorithmType,
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
    x: &[HashValue<N>; P],
) -> LMSResult<HashValue<N>> {
    let params = get_lmots_parameters(algo_type);
    assert_eq!(params.n as usize, N);
    assert_eq!(params.p as usize, P);
    let mut y = [HashValue::<N>::default(); P];
    for (i, xi) in x.iter().enumerate() {
        let mut tmp = *xi;
        let upper = (1 << params.w) - 1;
        for j in 0..upper {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(q);
            hasher.update(u16str(i as u16));
            hasher.update(u8str(j as u8));
            hasher.update(tmp);
            let t_blah = hasher.finalize();
            let mut blah = [0u8; N];
            for i in 0..N {
                blah[i] = t_blah[i];
            }
            tmp = HashValue::<N>::from(blah);
        }
        y[i] = tmp;
    }
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(u16str(D_PBLC));
    for t in y {
        hasher.update(t);
    }
    let t_blah = hasher.finalize();
    let mut blah = [0u8; N];
    for i in 0..N {
        blah[i] = t_blah[i];
    }
    let return_value = HashValue::<N>::from(blah);
    Ok(return_value)
}

// this is copied derived from section 5.2 of rfc 8554
fn create_lms_private_keys<const N: usize, const P: usize>(
    tree_height: u8,
    ots_type: &LmotsAlgorithmType,
) -> LMSResult<(LmsIdentifier, u32, Vec<[HashValue<N>; P]>)> {
    let lms_identifier: LmsIdentifier = random();
    let upper = 1 << tree_height;
    let mut ots_private = vec![];
    for _ in 0..upper {
        ots_private.push(create_lmots_private_key(ots_type)?);
    }
    Ok((lms_identifier, 0, ots_private))
}

pub fn create_lms_tree<const N: usize, const P: usize>(
    lms_type: &LmsAlgorithmType,
    ots_type: &LmotsAlgorithmType,
) -> LMSResult<(
    LmsIdentifier,
    u32,
    Vec<HashValue<N>>,
    Vec<[HashValue<N>; P]>,
)> {
    let (hash_size, tree_height) = get_lms_parameters(lms_type);
    assert_eq!(hash_size as usize, N);
    let num_nodes = 1 << (tree_height + 1); // we will instantiate an array to store the entire tree
    let mut t_tree = vec![HashValue::<N>::default(); num_nodes]; // the tree root will be at t_tree[1]
    let (lms_identifier, initial_q, private_keys) = create_lms_private_keys(tree_height, ots_type)?;
    if num_nodes != 2 * private_keys.len() {
        panic!("The tree needs to be twice the size of the number of private keys");
    }
    // Copy the public keys of the leaves into the leaves of the tree
    let initial_offset = private_keys.len();
    for offset in 0..private_keys.len() {
        let q = u32str(offset as u32);
        let ots_key =
            calculate_ots_public_key(ots_type, &lms_identifier, &q, &private_keys[offset])?;
        let mut hasher = Sha256::new();
        hasher.update(lms_identifier);
        let r = (initial_offset + offset) as u32;
        hasher.update(u32str(r));
        hasher.update(u16str(D_LEAF));
        hasher.update(ots_key);
        let t_blah = hasher.finalize();
        let mut blah = [0u8; N];
        for i in 0..N {
            blah[i] = t_blah[i];
        }
        t_tree[initial_offset + offset] = HashValue::<N>::from(blah);
    }
    // Now process each layer of tree from the bottom up
    for level in (1..(tree_height + 1)).rev() {
        let initial_offset = 1 << (level - 1);
        for offset in 0..initial_offset {
            let node_num = offset + initial_offset;
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(u32str(node_num));
            hasher.update(u16str(D_INTR));
            hasher.update(t_tree[2 * node_num as usize]);
            hasher.update(t_tree[(2 * node_num) as usize + 1]);
            let t_blah = hasher.finalize();
            let mut blah = [0u8; N];
            for i in 0..N {
                blah[i] = t_blah[i];
            }
            t_tree[node_num as usize] = HashValue::<N>::from(blah);
        }
    }

    Ok((lms_identifier, initial_q, t_tree, private_keys))
}

fn checksum(algo_type: &LmotsAlgorithmType, input_string: &[u8]) -> u16 {
    let params = get_lmots_parameters(algo_type);
    let mut sum = 0u16;
    let upper_bound = params.n as u16 * (8 / params.w as u16);
    for i in 0..upper_bound {
        sum = sum + ((1 << params.w) - 1)
            - (coefficient(input_string, i as usize, params.w as usize) as u16);
    }
    sum << params.ls
}

fn lmots_sign_message<const N: usize, const P: usize>(
    algo_type: &LmotsAlgorithmType,
    input_string: &[u8],
    private_key: &[HashValue<N>; P],
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
) -> LMSResult<LmotsSignature<N, P>> {
    let params = get_lmots_parameters(algo_type);
    assert_eq!(params.n as usize, N);
    assert_eq!(params.p as usize, P);
    let nonce_t: [u8; 32] = random(); // in the RFC this is the C value
    let mut nonce = [0u8; N];
    nonce[..N].copy_from_slice(&nonce_t[..N]);

    let mut y = [HashValue::<N>::default(); P];
    assert_eq!(private_key.len(), params.p as usize);
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(u16str(D_MESG));
    hasher.update(nonce);
    hasher.update(input_string);
    let tq = hasher.finalize();
    let mut message_hash_with_checksum = [0u8; 34]; // needs to be N + 2 extra bytes for the checksum.
    for (index, b) in tq.iter().enumerate() {
        message_hash_with_checksum[index] = *b;
    }
    let checksum_q = checksum(algo_type, &message_hash_with_checksum);
    let be_checksum = u16str(checksum_q);
    message_hash_with_checksum[N] = be_checksum[0];
    message_hash_with_checksum[N + 1] = be_checksum[1];

    for i in 0..params.p {
        let a = coefficient(&message_hash_with_checksum, i as usize, params.w as usize);
        let mut tmp = private_key[i as usize];
        for j in 0..a {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(q);
            hasher.update(u16str(i));
            hasher.update(u8str(j));
            hasher.update(tmp);
            let t_blah = hasher.finalize();
            let mut blah = [0u8; N];
            for i in 0..N {
                blah[i] = t_blah[i];
            }
            tmp = HashValue::<N>::from(blah);
        }
        y[i as usize] = tmp;
    }

    let signature = LmotsSignature {
        ots_type: *algo_type,
        nonce,
        y,
    };
    Ok(signature)
}

fn candidate_ots_signature<const N: usize, const P: usize>(
    algo_type: &LmotsAlgorithmType,
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
    signature: &LmotsSignature<N, P>,
    message: &[u8],
) -> LMSResult<HashValue<N>> {
    if algo_type != &signature.ots_type {
        println!("These have different ots types");
        assert_eq!(algo_type, &signature.ots_type);
    }
    let params = get_lmots_parameters(algo_type);
    assert_eq!(params.p as usize, P);
    assert!(params.n < 33);
    let mut hasher = Sha256::new();
    let mut z = [HashValue::<N>::default(); P];
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(u16str(D_MESG));
    hasher.update(signature.nonce);
    hasher.update(message);
    let tq = hasher.finalize();
    let mut message_hash_with_checksum = [0u8; 34]; // 2 extra bytes for the checksum. needs to be N+2
    for (index, b) in tq.iter().enumerate() {
        message_hash_with_checksum[index] = *b;
    }
    let checksum_q = checksum(algo_type, &message_hash_with_checksum);
    let be_checksum = u16str(checksum_q);
    message_hash_with_checksum[N] = be_checksum[0];
    message_hash_with_checksum[N + 1] = be_checksum[1];

    for i in 0..params.p {
        let a = coefficient(&message_hash_with_checksum, i as usize, params.w as usize);
        let mut tmp = signature.y[i as usize];
        let t_upper: u16 = (1 << params.w) - 1; // subtract with overflow?
        let upper = t_upper as u8;
        for j in a..upper {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(q);
            hasher.update(u16str(i));
            hasher.update(u8str(j));
            hasher.update(tmp);
            let t_blah = hasher.finalize();
            let mut blah = [0u8; N];
            for i in 0..N {
                blah[i] = t_blah[i];
            }
            tmp = HashValue::<N>::from(blah);
        }
        z[i as usize] = tmp;
    }
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(q);
    hasher.update(u16str(D_PBLC));
    for t in z {
        hasher.update(t);
    }
    let t_blah = hasher.finalize();
    let mut blah = [0u8; N];
    for i in 0..N {
        blah[i] = t_blah[i];
    }
    let result = HashValue::<N>::from(blah);
    Ok(result)
}

pub fn verify_ots_signature<const N: usize, const P: usize>(
    algo_type: &LmotsAlgorithmType,
    lms_identifier: &LmsIdentifier,
    q: &[u8; 4],
    public_key: &HashValue<N>,
    signature: &LmotsSignature<N, P>,
    message: &[u8],
) -> LMSResult<bool> {
    let final_result = candidate_ots_signature(algo_type, lms_identifier, q, signature, message)?;

    if final_result != *public_key {
        return Ok(false);
    }
    Ok(true)
}

pub fn lms_sign_message<const N: usize, const P: usize>(
    algo_type: &LmotsAlgorithmType,
    lms_algorithm: &LmsAlgorithmType,
    input_string: &[u8],
    t_tree: &[HashValue<N>],
    tree_height: u8,
    private_key: &[HashValue<N>; P],
    lms_identifier: &LmsIdentifier,
    q: u32,
) -> LMSResult<LmsSignature<N, P>> {
    let q_str = u32str(q);
    let lmots_sig =
        lmots_sign_message(algo_type, input_string, private_key, lms_identifier, &q_str)?;
    let mut path = vec![];

    let mut node_num = (1 << tree_height) + q;
    let mut sibling = node_num ^ 1;
    path.push(t_tree[sibling as usize]);
    for _ in 1..tree_height {
        node_num >>= 1;
        sibling = node_num ^ 1;
        path.push(t_tree[sibling as usize]);
    }
    let signature = LmsSignature {
        q,
        sig_type: *lms_algorithm,
        lmots_signature: lmots_sig,
        lms_path: path,
    };
    Ok(signature)
}

pub fn verify_lms_signature<const N: usize, const P: usize>(
    tree_height: u8,
    algo_type: &LmotsAlgorithmType,
    input_string: &[u8],
    lms_identifier: &LmsIdentifier,
    q: u32,
    lms_public_key: &HashValue<N>,
    lms_sig: &LmsSignature<N, P>,
) -> LMSResult<bool> {
    let q_str = u32str(q);
    let candidate_key = candidate_ots_signature(
        algo_type,
        lms_identifier,
        &q_str,
        &lms_sig.lmots_signature,
        input_string,
    )?;
    let mut node_num = (1 << tree_height) + q;
    let mut hasher = Sha256::new();
    hasher.update(lms_identifier);
    hasher.update(u32str(node_num));
    hasher.update(u16str(D_LEAF));
    hasher.update(candidate_key);
    let t_blah = hasher.finalize();
    let mut blah = [0u8; N];
    for i in 0..N {
        blah[i] = t_blah[i];
    }
    let mut temp = HashValue::<N>::from(blah);
    let mut i = 0;
    while node_num > 1 {
        if node_num % 2 == 1 {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(u32str(node_num / 2));
            hasher.update(u16str(D_INTR));
            hasher.update(lms_sig.lms_path[i]);
            hasher.update(temp);
            let t_blah = hasher.finalize();
            let mut blah = [0u8; N];
            for i in 0..N {
                blah[i] = t_blah[i];
            }
            temp = HashValue::<N>::from(blah);
        } else {
            let mut hasher = Sha256::new();
            hasher.update(lms_identifier);
            hasher.update(u32str(node_num / 2));
            hasher.update(u16str(D_INTR));
            hasher.update(temp);
            hasher.update(lms_sig.lms_path[i]);
            let t_blah = hasher.finalize();
            let mut blah = [0u8; N];
            for i in 0..N {
                blah[i] = t_blah[i];
            }
            temp = HashValue::<N>::from(blah);
        }
        node_num /= 2;
        i += 1;
    }
    let candidate_key = temp;
    if candidate_key != *lms_public_key {
        println!("Candidate LMS public key is {:?}", candidate_key);
        println!("The provided LMS key is     {:?}", lms_public_key);
        return Ok(false);
    }

    Ok(true)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn lmots_params_test() {
        let result = get_lmots_parameters(&LmotsAlgorithmType::LmotsSha256N32W4);
        assert_eq!(result.n, 32);
    }

    // test case from https://datatracker.ietf.org/doc/html/rfc8554#section-3.1.3
    #[test]
    fn test_coefficient() {
        let input_value = [0x12u8, 0x34u8];
        let result = coefficient(&input_value, 7, 1);
        assert_eq!(result, 0);

        let result = coefficient(&input_value, 0, 4);
        assert_eq!(result, 1);
    }

    #[test]
    fn hss_upper() {
        let _levels = 2;
        //let lms_type = 5;
        //let lmots_type = 4;
        let identifier: [u8; 16] = [
            0x61, 0xa5, 0xd5, 0x7d, 0x37, 0xf5, 0xe4, 0x6b, 0xfb, 0x75, 0x20, 0x80, 0x6b, 0x07,
            0xa1, 0xb8,
        ];
        let hss_public_key = Sha256Digest::from([
            0x50, 0x65, 0x0e, 0x3b, 0x31, 0xfe, 0x4a, 0x77, 0x3e, 0xa2, 0x9a, 0x07, 0xf0, 0x9c,
            0xf2, 0xea, 0x30, 0xe5, 0x79, 0xf0, 0xdf, 0x58, 0xef, 0x8e, 0x29, 0x8d, 0xa0, 0x43,
            0x4c, 0xb2, 0xb8, 0x78,
        ]);
        let _lower_public_hash: [u8; 32] = [
            0x6c, 0x50, 0x04, 0x91, 0x7d, 0xa6, 0xea, 0xfe, 0x4d, 0x9e, 0xf6, 0xc6, 0x40, 0x7b,
            0x3d, 0xb0, 0xe5, 0x48, 0x5b, 0x12, 0x2d, 0x9e, 0xbe, 0x15, 0xcd, 0xa9, 0x3c, 0xfe,
            0xc5, 0x82, 0xd7, 0xab,
        ];
        let _lower_public_identifier: [u8; 16] = [
            0xd2, 0xf1, 0x4f, 0xf6, 0x34, 0x6a, 0xf9, 0x64, 0x56, 0x9f, 0x7d, 0x6c, 0xb8, 0x80,
            0xa1, 0xb6,
        ];

        // In HSS the upper level tree signs the concatenation of
        // lower_tree_lms_type, lower_tree_lmots_type, lower_tree_I, lower_tree_pubic_hash
        let public_buffer: [u8; 56] = [
            0, 0, 0, 5, // lms_type
            0, 0, 0, 4, //lmots_type
            0xd2, 0xf1, 0x4f, 0xf6, 0x34, 0x6a, 0xf9, 0x64, 0x56, 0x9f, 0x7d, 0x6c, 0xb8, 0x80,
            0xa1, 0xb6, // I, aka identifier
            //the hash
            0x6c, 0x50, 0x04, 0x91, 0x7d, 0xa6, 0xea, 0xfe, 0x4d, 0x9e, 0xf6, 0xc6, 0x40, 0x7b,
            0x3d, 0xb0, 0xe5, 0x48, 0x5b, 0x12, 0x2d, 0x9e, 0xbe, 0x15, 0xcd, 0xa9, 0x3c, 0xfe,
            0xc5, 0x82, 0xd7, 0xab,
        ];

        let q = 5;
        let upper_nonce: [u8; 32] = [
            0xd3, 0x2b, 0x56, 0x67, 0x1d, 0x7e, 0xb9, 0x88, 0x33, 0xc4, 0x9b, 0x43, 0x3c, 0x27,
            0x25, 0x86, 0xbc, 0x4a, 0x1c, 0x8a, 0x89, 0x70, 0x52, 0x8f, 0xfa, 0x04, 0xb9, 0x66,
            0xf9, 0x42, 0x6e, 0xb9,
        ];

        let y: [Sha256Digest; 34] = [
            Sha256Digest::from([
                0x96, 0x5a, 0x25, 0xbf, 0xd3, 0x7f, 0x19, 0x6b, 0x90, 0x73, 0xf3, 0xd4, 0xa2, 0x32,
                0xfe, 0xb6, 0x91, 0x28, 0xec, 0x45, 0x14, 0x6f, 0x86, 0x29, 0x2f, 0x9d, 0xff, 0x96,
                0x10, 0xa7, 0xbf, 0x95,
            ]),
            Sha256Digest::from([
                0xa6, 0x4c, 0x7f, 0x60, 0xf6, 0x26, 0x1a, 0x62, 0x04, 0x3f, 0x86, 0xc7, 0x03, 0x24,
                0xb7, 0x70, 0x7f, 0x5b, 0x4a, 0x8a, 0x6e, 0x19, 0xc1, 0x14, 0xc7, 0xbe, 0x86, 0x6d,
                0x48, 0x87, 0x78, 0xa0,
            ]),
            Sha256Digest::from([
                0xe0, 0x5f, 0xd5, 0xc6, 0x50, 0x9a, 0x6e, 0x61, 0xd5, 0x59, 0xcf, 0x1a, 0x77, 0xa9,
                0x70, 0xde, 0x92, 0x7d, 0x60, 0xc7, 0x0d, 0x3d, 0xe3, 0x1a, 0x7f, 0xa0, 0x10, 0x09,
                0x94, 0xe1, 0x62, 0xa2,
            ]),
            Sha256Digest::from([
                0x58, 0x2e, 0x8f, 0xf1, 0xb1, 0x0c, 0xd9, 0x9d, 0x4e, 0x8e, 0x41, 0x3e, 0xf4, 0x69,
                0x55, 0x9f, 0x7d, 0x7e, 0xd1, 0x2c, 0x83, 0x83, 0x42, 0xf9, 0xb9, 0xc9, 0x6b, 0x83,
                0xa4, 0x94, 0x3d, 0x16,
            ]),
            Sha256Digest::from([
                0x81, 0xd8, 0x4b, 0x15, 0x35, 0x7f, 0xf4, 0x8c, 0xa5, 0x79, 0xf1, 0x9f, 0x5e, 0x71,
                0xf1, 0x84, 0x66, 0xf2, 0xbb, 0xef, 0x4b, 0xf6, 0x60, 0xc2, 0x51, 0x8e, 0xb2, 0x0d,
                0xe2, 0xf6, 0x6e, 0x3b,
            ]),
            Sha256Digest::from([
                0x14, 0x78, 0x42, 0x69, 0xd7, 0xd8, 0x76, 0xf5, 0xd3, 0x5d, 0x3f, 0xbf, 0xc7, 0x03,
                0x9a, 0x46, 0x2c, 0x71, 0x6b, 0xb9, 0xf6, 0x89, 0x1a, 0x7f, 0x41, 0xad, 0x13, 0x3e,
                0x9e, 0x1f, 0x6d, 0x95,
            ]),
            Sha256Digest::from([
                0x60, 0xb9, 0x60, 0xe7, 0x77, 0x7c, 0x52, 0xf0, 0x60, 0x49, 0x2f, 0x2d, 0x7c, 0x66,
                0x0e, 0x14, 0x71, 0xe0, 0x7e, 0x72, 0x65, 0x55, 0x62, 0x03, 0x5a, 0xbc, 0x9a, 0x70,
                0x1b, 0x47, 0x3e, 0xcb,
            ]),
            Sha256Digest::from([
                0xc3, 0x94, 0x3c, 0x6b, 0x9c, 0x4f, 0x24, 0x05, 0xa3, 0xcb, 0x8b, 0xf8, 0xa6, 0x91,
                0xca, 0x51, 0xd3, 0xf6, 0xad, 0x2f, 0x42, 0x8b, 0xab, 0x6f, 0x3a, 0x30, 0xf5, 0x5d,
                0xd9, 0x62, 0x55, 0x63,
            ]),
            Sha256Digest::from([
                0xf0, 0xa7, 0x5e, 0xe3, 0x90, 0xe3, 0x85, 0xe3, 0xae, 0x0b, 0x90, 0x69, 0x61, 0xec,
                0xf4, 0x1a, 0xe0, 0x73, 0xa0, 0x59, 0x0c, 0x2e, 0xb6, 0x20, 0x4f, 0x44, 0x83, 0x1c,
                0x26, 0xdd, 0x76, 0x8c,
            ]),
            Sha256Digest::from([
                0x35, 0xb1, 0x67, 0xb2, 0x8c, 0xe8, 0xdc, 0x98, 0x8a, 0x37, 0x48, 0x25, 0x52, 0x30,
                0xce, 0xf9, 0x9e, 0xbf, 0x14, 0xe7, 0x30, 0x63, 0x2f, 0x27, 0x41, 0x44, 0x89, 0x80,
                0x8a, 0xfa, 0xb1, 0xd1,
            ]),
            Sha256Digest::from([
                0xe7, 0x83, 0xed, 0x04, 0x51, 0x6d, 0xe0, 0x12, 0x49, 0x86, 0x82, 0x21, 0x2b, 0x07,
                0x81, 0x05, 0x79, 0xb2, 0x50, 0x36, 0x59, 0x41, 0xbc, 0xc9, 0x81, 0x42, 0xda, 0x13,
                0x60, 0x9e, 0x97, 0x68,
            ]),
            Sha256Digest::from([
                0xaa, 0xf6, 0x5d, 0xe7, 0x62, 0x0d, 0xab, 0xec, 0x29, 0xeb, 0x82, 0xa1, 0x7f, 0xde,
                0x35, 0xaf, 0x15, 0xad, 0x23, 0x8c, 0x73, 0xf8, 0x1b, 0xdb, 0x8d, 0xec, 0x2f, 0xc0,
                0xe7, 0xf9, 0x32, 0x70,
            ]),
            Sha256Digest::from([
                0x10, 0x99, 0x76, 0x2b, 0x37, 0xf4, 0x3c, 0x4a, 0x3c, 0x20, 0x01, 0x0a, 0x3d, 0x72,
                0xe2, 0xf6, 0x06, 0xbe, 0x10, 0x8d, 0x31, 0x0e, 0x63, 0x9f, 0x09, 0xce, 0x72, 0x86,
                0x80, 0x0d, 0x9e, 0xf8,
            ]),
            Sha256Digest::from([
                0xa1, 0xa4, 0x02, 0x81, 0xcc, 0x5a, 0x7e, 0xa9, 0x8d, 0x2a, 0xdc, 0x7c, 0x74, 0x00,
                0xc2, 0xfe, 0x5a, 0x10, 0x15, 0x52, 0xdf, 0x4e, 0x3c, 0xcc, 0xfd, 0x0c, 0xbf, 0x2d,
                0xdf, 0x5d, 0xc6, 0x77,
            ]),
            Sha256Digest::from([
                0x9c, 0xbb, 0xc6, 0x8f, 0xee, 0x0c, 0x3e, 0xfe, 0x4e, 0xc2, 0x2b, 0x83, 0xa2, 0xca,
                0xa3, 0xe4, 0x8e, 0x08, 0x09, 0xa0, 0xa7, 0x50, 0xb7, 0x3c, 0xcd, 0xcf, 0x3c, 0x79,
                0xe6, 0x58, 0x0c, 0x15,
            ]),
            Sha256Digest::from([
                0x4f, 0x8a, 0x58, 0xf7, 0xf2, 0x43, 0x35, 0xee, 0xc5, 0xc5, 0xeb, 0x5e, 0x0c, 0xf0,
                0x1d, 0xcf, 0x44, 0x39, 0x42, 0x40, 0x95, 0xfc, 0xeb, 0x07, 0x7f, 0x66, 0xde, 0xd5,
                0xbe, 0xc7, 0x3b, 0x27,
            ]),
            Sha256Digest::from([
                0xc5, 0xb9, 0xf6, 0x4a, 0x2a, 0x9a, 0xf2, 0xf0, 0x7c, 0x05, 0xe9, 0x9e, 0x5c, 0xf8,
                0x0f, 0x00, 0x25, 0x2e, 0x39, 0xdb, 0x32, 0xf6, 0xc1, 0x96, 0x74, 0xf1, 0x90, 0xc9,
                0xfb, 0xc5, 0x06, 0xd8,
            ]),
            Sha256Digest::from([
                0x26, 0x85, 0x77, 0x13, 0xaf, 0xd2, 0xca, 0x6b, 0xb8, 0x5c, 0xd8, 0xc1, 0x07, 0x34,
                0x75, 0x52, 0xf3, 0x05, 0x75, 0xa5, 0x41, 0x78, 0x16, 0xab, 0x4d, 0xb3, 0xf6, 0x03,
                0xf2, 0xdf, 0x56, 0xfb,
            ]),
            Sha256Digest::from([
                0xc4, 0x13, 0xe7, 0xd0, 0xac, 0xd8, 0xbd, 0xd8, 0x13, 0x52, 0xb2, 0x47, 0x1f, 0xc1,
                0xbc, 0x4f, 0x1e, 0xf2, 0x96, 0xfe, 0xa1, 0x22, 0x04, 0x03, 0x46, 0x6b, 0x1a, 0xfe,
                0x78, 0xb9, 0x4f, 0x7e,
            ]),
            Sha256Digest::from([
                0xcf, 0x7c, 0xc6, 0x2f, 0xb9, 0x2b, 0xe1, 0x4f, 0x18, 0xc2, 0x19, 0x23, 0x84, 0xeb,
                0xce, 0xaf, 0x88, 0x01, 0xaf, 0xdf, 0x94, 0x7f, 0x69, 0x8c, 0xe9, 0xc6, 0xce, 0xb6,
                0x96, 0xed, 0x70, 0xe9,
            ]),
            Sha256Digest::from([
                0xe8, 0x7b, 0x01, 0x44, 0x41, 0x7e, 0x8d, 0x7b, 0xaf, 0x25, 0xeb, 0x5f, 0x70, 0xf0,
                0x9f, 0x01, 0x6f, 0xc9, 0x25, 0xb4, 0xdb, 0x04, 0x8a, 0xb8, 0xd8, 0xcb, 0x2a, 0x66,
                0x1c, 0xe3, 0xb5, 0x7a,
            ]),
            Sha256Digest::from([
                0xda, 0x67, 0x57, 0x1f, 0x5d, 0xd5, 0x46, 0xfc, 0x22, 0xcb, 0x1f, 0x97, 0xe0, 0xeb,
                0xd1, 0xa6, 0x59, 0x26, 0xb1, 0x23, 0x4f, 0xd0, 0x4f, 0x17, 0x1c, 0xf4, 0x69, 0xc7,
                0x6b, 0x88, 0x4c, 0xf3,
            ]),
            Sha256Digest::from([
                0x11, 0x5c, 0xce, 0x6f, 0x79, 0x2c, 0xc8, 0x4e, 0x36, 0xda, 0x58, 0x96, 0x0c, 0x5f,
                0x1d, 0x76, 0x0f, 0x32, 0xc1, 0x2f, 0xae, 0xf4, 0x77, 0xe9, 0x4c, 0x92, 0xeb, 0x75,
                0x62, 0x5b, 0x6a, 0x37,
            ]),
            Sha256Digest::from([
                0x1e, 0xfc, 0x72, 0xd6, 0x0c, 0xa5, 0xe9, 0x08, 0xb3, 0xa7, 0xdd, 0x69, 0xfe, 0xf0,
                0x24, 0x91, 0x50, 0xe3, 0xee, 0xbd, 0xfe, 0xd3, 0x9c, 0xbd, 0xc3, 0xce, 0x97, 0x04,
                0x88, 0x2a, 0x20, 0x72,
            ]),
            Sha256Digest::from([
                0xc7, 0x5e, 0x13, 0x52, 0x7b, 0x7a, 0x58, 0x1a, 0x55, 0x61, 0x68, 0x78, 0x3d, 0xc1,
                0xe9, 0x75, 0x45, 0xe3, 0x18, 0x65, 0xdd, 0xc4, 0x6b, 0x3c, 0x95, 0x78, 0x35, 0xda,
                0x25, 0x2b, 0xb7, 0x32,
            ]),
            Sha256Digest::from([
                0x8d, 0x3e, 0xe2, 0x06, 0x24, 0x45, 0xdf, 0xb8, 0x5e, 0xf8, 0xc3, 0x5f, 0x8e, 0x1f,
                0x33, 0x71, 0xaf, 0x34, 0x02, 0x3c, 0xef, 0x62, 0x6e, 0x0a, 0xf1, 0xe0, 0xbc, 0x01,
                0x73, 0x51, 0xaa, 0xe2,
            ]),
            Sha256Digest::from([
                0xab, 0x8f, 0x5c, 0x61, 0x2e, 0xad, 0x0b, 0x72, 0x9a, 0x1d, 0x05, 0x9d, 0x02, 0xbf,
                0xe1, 0x8e, 0xfa, 0x97, 0x1b, 0x73, 0x00, 0xe8, 0x82, 0x36, 0x0a, 0x93, 0xb0, 0x25,
                0xff, 0x97, 0xe9, 0xe0,
            ]),
            Sha256Digest::from([
                0xee, 0xc0, 0xf3, 0xf3, 0xf1, 0x30, 0x39, 0xa1, 0x7f, 0x88, 0xb0, 0xcf, 0x80, 0x8f,
                0x48, 0x84, 0x31, 0x60, 0x6c, 0xb1, 0x3f, 0x92, 0x41, 0xf4, 0x0f, 0x44, 0xe5, 0x37,
                0xd3, 0x02, 0xc6, 0x4a,
            ]),
            Sha256Digest::from([
                0x4f, 0x1f, 0x4a, 0xb9, 0x49, 0xb9, 0xfe, 0xef, 0xad, 0xcb, 0x71, 0xab, 0x50, 0xef,
                0x27, 0xd6, 0xd6, 0xca, 0x85, 0x10, 0xf1, 0x50, 0xc8, 0x5f, 0xb5, 0x25, 0xbf, 0x25,
                0x70, 0x3d, 0xf7, 0x20,
            ]),
            Sha256Digest::from([
                0x9b, 0x60, 0x66, 0xf0, 0x9c, 0x37, 0x28, 0x0d, 0x59, 0x12, 0x8d, 0x2f, 0x0f, 0x63,
                0x7c, 0x7d, 0x7d, 0x7f, 0xad, 0x4e, 0xd1, 0xc1, 0xea, 0x04, 0xe6, 0x28, 0xd2, 0x21,
                0xe3, 0xd8, 0xdb, 0x77,
            ]),
            Sha256Digest::from([
                0xb7, 0xc8, 0x78, 0xc9, 0x41, 0x1c, 0xaf, 0xc5, 0x07, 0x1a, 0x34, 0xa0, 0x0f, 0x4c,
                0xf0, 0x77, 0x38, 0x91, 0x27, 0x53, 0xdf, 0xce, 0x48, 0xf0, 0x75, 0x76, 0xf0, 0xd4,
                0xf9, 0x4f, 0x42, 0xc6,
            ]),
            Sha256Digest::from([
                0xd7, 0x6f, 0x7c, 0xe9, 0x73, 0xe9, 0x36, 0x70, 0x95, 0xba, 0x7e, 0x9a, 0x36, 0x49,
                0xb7, 0xf4, 0x61, 0xd9, 0xf9, 0xac, 0x13, 0x32, 0xa4, 0xd1, 0x04, 0x4c, 0x96, 0xae,
                0xfe, 0xe6, 0x76, 0x76,
            ]),
            Sha256Digest::from([
                0x40, 0x1b, 0x64, 0x45, 0x7c, 0x54, 0xd6, 0x5f, 0xef, 0x65, 0x00, 0xc5, 0x9c, 0xdf,
                0xb6, 0x9a, 0xf7, 0xb6, 0xdd, 0xdf, 0xcb, 0x0f, 0x08, 0x62, 0x78, 0xdd, 0x8a, 0xd0,
                0x68, 0x60, 0x78, 0xdf,
            ]),
            Sha256Digest::from([
                0xb0, 0xf3, 0xf7, 0x9c, 0xd8, 0x93, 0xd3, 0x14, 0x16, 0x86, 0x48, 0x49, 0x98, 0x98,
                0xfb, 0xc0, 0xce, 0xd5, 0xf9, 0x5b, 0x74, 0xe8, 0xff, 0x14, 0xd7, 0x35, 0xcd, 0xea,
                0x96, 0x8b, 0xee, 0x74,
            ]),
        ];
        let path: [Sha256Digest; 5] = [
            Sha256Digest::from([
                0xd8, 0xb8, 0x11, 0x2f, 0x92, 0x00, 0xa5, 0xe5, 0x0c, 0x4a, 0x26, 0x21, 0x65, 0xbd,
                0x34, 0x2c, 0xd8, 0x00, 0xb8, 0x49, 0x68, 0x10, 0xbc, 0x71, 0x62, 0x77, 0x43, 0x5a,
                0xc3, 0x76, 0x72, 0x8d,
            ]),
            Sha256Digest::from([
                0x12, 0x9a, 0xc6, 0xed, 0xa8, 0x39, 0xa6, 0xf3, 0x57, 0xb5, 0xa0, 0x43, 0x87, 0xc5,
                0xce, 0x97, 0x38, 0x2a, 0x78, 0xf2, 0xa4, 0x37, 0x29, 0x17, 0xee, 0xfc, 0xbf, 0x93,
                0xf6, 0x3b, 0xb5, 0x91,
            ]),
            Sha256Digest::from([
                0x12, 0xf5, 0xdb, 0xe4, 0x00, 0xbd, 0x49, 0xe4, 0x50, 0x1e, 0x85, 0x9f, 0x88, 0x5b,
                0xf0, 0x73, 0x6e, 0x90, 0xa5, 0x09, 0xb3, 0x0a, 0x26, 0xbf, 0xac, 0x8c, 0x17, 0xb5,
                0x99, 0x1c, 0x15, 0x7e,
            ]),
            Sha256Digest::from([
                0xb5, 0x97, 0x11, 0x15, 0xaa, 0x39, 0xef, 0xd8, 0xd5, 0x64, 0xa6, 0xb9, 0x02, 0x82,
                0xc3, 0x16, 0x8a, 0xf2, 0xd3, 0x0e, 0xf8, 0x9d, 0x51, 0xbf, 0x14, 0x65, 0x45, 0x10,
                0xa1, 0x2b, 0x8a, 0x14,
            ]),
            Sha256Digest::from([
                0x4c, 0xca, 0x18, 0x48, 0xcf, 0x7d, 0xa5, 0x9c, 0xc2, 0xb3, 0xd9, 0xd0, 0x69, 0x2d,
                0xd2, 0xa2, 0x0b, 0xa3, 0x86, 0x34, 0x80, 0xe2, 0x5b, 0x1b, 0x85, 0xee, 0x86, 0x0c,
                0x62, 0xbf, 0x51, 0x36,
            ]),
        ];

        let upper_ots = LmotsSignature {
            ots_type: LmotsAlgorithmType::LmotsSha256N32W8,
            nonce: upper_nonce,
            y,
        };

        let upper_signature = LmsSignature {
            q,
            lmots_signature: upper_ots,
            sig_type: LmsAlgorithmType::LmsSha256N32H5,
            lms_path: Vec::from(path),
        };

        let success = verify_lms_signature(
            5,
            &LmotsAlgorithmType::LmotsSha256N32W8,
            &public_buffer,
            &identifier,
            q,
            &hss_public_key,
            &upper_signature,
        ).unwrap();
        assert!(success);
    }

    #[test]
    fn lms_lower() {
        let message: [u8; 162] = [
            0x54, 0x68, 0x65, 0x20, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x73, 0x20, 0x6e, 0x6f, 0x74,
            0x20, 0x64, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,
            0x74, 0x68, 0x65, 0x20, 0x55, 0x6e, 0x69, 0x74, 0x65, 0x64, 0x20, 0x53, 0x74, 0x61,
            0x74, 0x65, 0x73, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e,
            0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x6e, 0x6f, 0x72,
            0x20, 0x70, 0x72, 0x6f, 0x68, 0x69, 0x62, 0x69, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79,
            0x20, 0x69, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x74, 0x61,
            0x74, 0x65, 0x73, 0x2c, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72,
            0x76, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x74, 0x61,
            0x74, 0x65, 0x73, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65,
            0x6c, 0x79, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
            0x70, 0x65, 0x6f, 0x70, 0x6c, 0x65, 0x2e, 0x0a,
        ];
        let lms_public_identifier: [u8; 16] = [
            0xd2, 0xf1, 0x4f, 0xf6, 0x34, 0x6a, 0xf9, 0x64, 0x56, 0x9f, 0x7d, 0x6c, 0xb8, 0x80,
            0xa1, 0xb6,
        ];

        let lms_public_key = Sha256Digest::from([
            0x6c, 0x50, 0x04, 0x91, 0x7d, 0xa6, 0xea, 0xfe, 0x4d, 0x9e, 0xf6, 0xc6, 0x40, 0x7b,
            0x3d, 0xb0, 0xe5, 0x48, 0x5b, 0x12, 0x2d, 0x9e, 0xbe, 0x15, 0xcd, 0xa9, 0x3c, 0xfe,
            0xc5, 0x82, 0xd7, 0xab,
        ]);

        // final signature
        let lms_q = 0xa;
        let final_c: [u8; 32] = [
            0x07, 0x03, 0xc4, 0x91, 0xe7, 0x55, 0x8b, 0x35, 0x01, 0x1e, 0xce, 0x35, 0x92, 0xea,
            0xa5, 0xda, 0x4d, 0x91, 0x87, 0x86, 0x77, 0x12, 0x33, 0xe8, 0x35, 0x3b, 0xc4, 0xf6,
            0x23, 0x23, 0x18, 0x5c,
        ];
        let final_y: [Sha256Digest; 34] = [
            Sha256Digest::from([
                0x95, 0xca, 0xe0, 0x5b, 0x89, 0x9e, 0x35, 0xdf, 0xfd, 0x71, 0x70, 0x54, 0x70, 0x62,
                0x09, 0x98, 0x8e, 0xbf, 0xdf, 0x6e, 0x37, 0x96, 0x0b, 0xb5, 0xc3, 0x8d, 0x76, 0x57,
                0xe8, 0xbf, 0xfe, 0xef,
            ]),
            Sha256Digest::from([
                0x9b, 0xc0, 0x42, 0xda, 0x4b, 0x45, 0x25, 0x65, 0x04, 0x85, 0xc6, 0x6d, 0x0c, 0xe1,
                0x9b, 0x31, 0x75, 0x87, 0xc6, 0xba, 0x4b, 0xff, 0xcc, 0x42, 0x8e, 0x25, 0xd0, 0x89,
                0x31, 0xe7, 0x2d, 0xfb,
            ]),
            Sha256Digest::from([
                0x6a, 0x12, 0x0c, 0x56, 0x12, 0x34, 0x42, 0x58, 0xb8, 0x5e, 0xfd, 0xb7, 0xdb, 0x1d,
                0xb9, 0xe1, 0x86, 0x5a, 0x73, 0xca, 0xf9, 0x65, 0x57, 0xeb, 0x39, 0xed, 0x3e, 0x3f,
                0x42, 0x69, 0x33, 0xac,
            ]),
            Sha256Digest::from([
                0x9e, 0xed, 0xdb, 0x03, 0xa1, 0xd2, 0x37, 0x4a, 0xf7, 0xbf, 0x77, 0x18, 0x55, 0x77,
                0x45, 0x62, 0x37, 0xf9, 0xde, 0x2d, 0x60, 0x11, 0x3c, 0x23, 0xf8, 0x46, 0xdf, 0x26,
                0xfa, 0x94, 0x20, 0x08,
            ]),
            Sha256Digest::from([
                0xa6, 0x98, 0x99, 0x4c, 0x08, 0x27, 0xd9, 0x0e, 0x86, 0xd4, 0x3e, 0x0d, 0xf7, 0xf4,
                0xbf, 0xcd, 0xb0, 0x9b, 0x86, 0xa3, 0x73, 0xb9, 0x82, 0x88, 0xb7, 0x09, 0x4a, 0xd8,
                0x1a, 0x01, 0x85, 0xac,
            ]),
            Sha256Digest::from([
                0x10, 0x0e, 0x4f, 0x2c, 0x5f, 0xc3, 0x8c, 0x00, 0x3c, 0x1a, 0xb6, 0xfe, 0xa4, 0x79,
                0xeb, 0x2f, 0x5e, 0xbe, 0x48, 0xf5, 0x84, 0xd7, 0x15, 0x9b, 0x8a, 0xda, 0x03, 0x58,
                0x6e, 0x65, 0xad, 0x9c,
            ]),
            Sha256Digest::from([
                0x96, 0x9f, 0x6a, 0xec, 0xbf, 0xe4, 0x4c, 0xf3, 0x56, 0x88, 0x8a, 0x7b, 0x15, 0xa3,
                0xff, 0x07, 0x4f, 0x77, 0x17, 0x60, 0xb2, 0x6f, 0x9c, 0x04, 0x88, 0x4e, 0xe1, 0xfa,
                0xa3, 0x29, 0xfb, 0xf4,
            ]),
            Sha256Digest::from([
                0xe6, 0x1a, 0xf2, 0x3a, 0xee, 0x7f, 0xa5, 0xd4, 0xd9, 0xa5, 0xdf, 0xcf, 0x43, 0xc4,
                0xc2, 0x6c, 0xe8, 0xae, 0xa2, 0xce, 0x8a, 0x29, 0x90, 0xd7, 0xba, 0x7b, 0x57, 0x10,
                0x8b, 0x47, 0xda, 0xbf,
            ]),
            Sha256Digest::from([
                0xbe, 0xad, 0xb2, 0xb2, 0x5b, 0x3c, 0xac, 0xc1, 0xac, 0x0c, 0xef, 0x34, 0x6c, 0xbb,
                0x90, 0xfb, 0x04, 0x4b, 0xee, 0xe4, 0xfa, 0xc2, 0x60, 0x3a, 0x44, 0x2b, 0xdf, 0x7e,
                0x50, 0x72, 0x43, 0xb7,
            ]),
            Sha256Digest::from([
                0x31, 0x9c, 0x99, 0x44, 0xb1, 0x58, 0x6e, 0x89, 0x9d, 0x43, 0x1c, 0x7f, 0x91, 0xbc,
                0xcc, 0xc8, 0x69, 0x0d, 0xbf, 0x59, 0xb2, 0x83, 0x86, 0xb2, 0x31, 0x5f, 0x3d, 0x36,
                0xef, 0x2e, 0xaa, 0x3c,
            ]),
            Sha256Digest::from([
                0xf3, 0x0b, 0x2b, 0x51, 0xf4, 0x8b, 0x71, 0xb0, 0x03, 0xdf, 0xb0, 0x82, 0x49, 0x48,
                0x42, 0x01, 0x04, 0x3f, 0x65, 0xf5, 0xa3, 0xef, 0x6b, 0xbd, 0x61, 0xdd, 0xfe, 0xe8,
                0x1a, 0xca, 0x9c, 0xe6,
            ]),
            Sha256Digest::from([
                0x00, 0x81, 0x26, 0x2a, 0x00, 0x00, 0x04, 0x80, 0xdc, 0xbc, 0x9a, 0x3d, 0xa6, 0xfb,
                0xef, 0x5c, 0x1c, 0x0a, 0x55, 0xe4, 0x8a, 0x0e, 0x72, 0x9f, 0x91, 0x84, 0xfc, 0xb1,
                0x40, 0x7c, 0x31, 0x52,
            ]),
            Sha256Digest::from([
                0x9d, 0xb2, 0x68, 0xf6, 0xfe, 0x50, 0x03, 0x2a, 0x36, 0x3c, 0x98, 0x01, 0x30, 0x68,
                0x37, 0xfa, 0xfa, 0xbd, 0xf9, 0x57, 0xfd, 0x97, 0xea, 0xfc, 0x80, 0xdb, 0xd1, 0x65,
                0xe4, 0x35, 0xd0, 0xe2,
            ]),
            Sha256Digest::from([
                0xdf, 0xd8, 0x36, 0xa2, 0x8b, 0x35, 0x40, 0x23, 0x92, 0x4b, 0x6f, 0xb7, 0xe4, 0x8b,
                0xc0, 0xb3, 0xed, 0x95, 0xee, 0xa6, 0x4c, 0x2d, 0x40, 0x2f, 0x4d, 0x73, 0x4c, 0x8d,
                0xc2, 0x6f, 0x3a, 0xc5,
            ]),
            Sha256Digest::from([
                0x91, 0x82, 0x5d, 0xae, 0xf0, 0x1e, 0xae, 0x3c, 0x38, 0xe3, 0x32, 0x8d, 0x00, 0xa7,
                0x7d, 0xc6, 0x57, 0x03, 0x4f, 0x28, 0x7c, 0xcb, 0x0f, 0x0e, 0x1c, 0x9a, 0x7c, 0xbd,
                0xc8, 0x28, 0xf6, 0x27,
            ]),
            Sha256Digest::from([
                0x20, 0x5e, 0x47, 0x37, 0xb8, 0x4b, 0x58, 0x37, 0x65, 0x51, 0xd4, 0x4c, 0x12, 0xc3,
                0xc2, 0x15, 0xc8, 0x12, 0xa0, 0x97, 0x07, 0x89, 0xc8, 0x3d, 0xe5, 0x1d, 0x6a, 0xd7,
                0x87, 0x27, 0x19, 0x63,
            ]),
            Sha256Digest::from([
                0x32, 0x7f, 0x0a, 0x5f, 0xbb, 0x6b, 0x59, 0x07, 0xde, 0xc0, 0x2c, 0x9a, 0x90, 0x93,
                0x4a, 0xf5, 0xa1, 0xc6, 0x3b, 0x72, 0xc8, 0x26, 0x53, 0x60, 0x5d, 0x1d, 0xcc, 0xe5,
                0x15, 0x96, 0xb3, 0xc2,
            ]),
            Sha256Digest::from([
                0xb4, 0x56, 0x96, 0x68, 0x9f, 0x2e, 0xb3, 0x82, 0x00, 0x74, 0x97, 0x55, 0x76, 0x92,
                0xca, 0xac, 0x4d, 0x57, 0xb5, 0xde, 0x9f, 0x55, 0x69, 0xbc, 0x2a, 0xd0, 0x13, 0x7f,
                0xd4, 0x7f, 0xb4, 0x7e,
            ]),
            Sha256Digest::from([
                0x66, 0x4f, 0xcb, 0x6d, 0xb4, 0x97, 0x1f, 0x5b, 0x3e, 0x07, 0xac, 0xed, 0xa9, 0xac,
                0x13, 0x0e, 0x9f, 0x38, 0x18, 0x2d, 0xe9, 0x94, 0xcf, 0xf1, 0x92, 0xec, 0x0e, 0x82,
                0xfd, 0x6d, 0x4c, 0xb7,
            ]),
            Sha256Digest::from([
                0xf3, 0xfe, 0x00, 0x81, 0x25, 0x89, 0xb7, 0xa7, 0xce, 0x51, 0x54, 0x40, 0x45, 0x64,
                0x33, 0x01, 0x6b, 0x84, 0xa5, 0x9b, 0xec, 0x66, 0x19, 0xa1, 0xc6, 0xc0, 0xb3, 0x7d,
                0xd1, 0x45, 0x0e, 0xd4,
            ]),
            Sha256Digest::from([
                0xf2, 0xd8, 0xb5, 0x84, 0x41, 0x0c, 0xed, 0xa8, 0x02, 0x5f, 0x5d, 0x2d, 0x8d, 0xd0,
                0xd2, 0x17, 0x6f, 0xc1, 0xcf, 0x2c, 0xc0, 0x6f, 0xa8, 0xc8, 0x2b, 0xed, 0x4d, 0x94,
                0x4e, 0x71, 0x33, 0x9e,
            ]),
            Sha256Digest::from([
                0xce, 0x78, 0x0f, 0xd0, 0x25, 0xbd, 0x41, 0xec, 0x34, 0xeb, 0xff, 0x9d, 0x42, 0x70,
                0xa3, 0x22, 0x4e, 0x01, 0x9f, 0xcb, 0x44, 0x44, 0x74, 0xd4, 0x82, 0xfd, 0x2d, 0xbe,
                0x75, 0xef, 0xb2, 0x03,
            ]),
            Sha256Digest::from([
                0x89, 0xcc, 0x10, 0xcd, 0x60, 0x0a, 0xbb, 0x54, 0xc4, 0x7e, 0xde, 0x93, 0xe0, 0x8c,
                0x11, 0x4e, 0xdb, 0x04, 0x11, 0x7d, 0x71, 0x4d, 0xc1, 0xd5, 0x25, 0xe1, 0x1b, 0xed,
                0x87, 0x56, 0x19, 0x2f,
            ]),
            Sha256Digest::from([
                0x92, 0x9d, 0x15, 0x46, 0x2b, 0x93, 0x9f, 0xf3, 0xf5, 0x2f, 0x22, 0x52, 0xda, 0x2e,
                0xd6, 0x4d, 0x8f, 0xae, 0x88, 0x81, 0x8b, 0x1e, 0xfa, 0x2c, 0x7b, 0x08, 0xc8, 0x79,
                0x4f, 0xb1, 0xb2, 0x14,
            ]),
            Sha256Digest::from([
                0xaa, 0x23, 0x3d, 0xb3, 0x16, 0x28, 0x33, 0x14, 0x1e, 0xa4, 0x38, 0x3f, 0x1a, 0x6f,
                0x12, 0x0b, 0xe1, 0xdb, 0x82, 0xce, 0x36, 0x30, 0xb3, 0x42, 0x91, 0x14, 0x46, 0x31,
                0x57, 0xa6, 0x4e, 0x91,
            ]),
            Sha256Digest::from([
                0x23, 0x4d, 0x47, 0x5e, 0x2f, 0x79, 0xcb, 0xf0, 0x5e, 0x4d, 0xb6, 0xa9, 0x40, 0x7d,
                0x72, 0xc6, 0xbf, 0xf7, 0xd1, 0x19, 0x8b, 0x5c, 0x4d, 0x6a, 0xad, 0x28, 0x31, 0xdb,
                0x61, 0x27, 0x49, 0x93,
            ]),
            Sha256Digest::from([
                0x71, 0x5a, 0x01, 0x82, 0xc7, 0xdc, 0x80, 0x89, 0xe3, 0x2c, 0x85, 0x31, 0xde, 0xed,
                0x4f, 0x74, 0x31, 0xc0, 0x7c, 0x02, 0x19, 0x5e, 0xba, 0x2e, 0xf9, 0x1e, 0xfb, 0x56,
                0x13, 0xc3, 0x7a, 0xf7,
            ]),
            Sha256Digest::from([
                0xae, 0x0c, 0x06, 0x6b, 0xab, 0xc6, 0x93, 0x69, 0x70, 0x0e, 0x1d, 0xd2, 0x6e, 0xdd,
                0xc0, 0xd2, 0x16, 0xc7, 0x81, 0xd5, 0x6e, 0x4c, 0xe4, 0x7e, 0x33, 0x03, 0xfa, 0x73,
                0x00, 0x7f, 0xf7, 0xb9,
            ]),
            Sha256Digest::from([
                0x49, 0xef, 0x23, 0xbe, 0x2a, 0xa4, 0xdb, 0xf2, 0x52, 0x06, 0xfe, 0x45, 0xc2, 0x0d,
                0xd8, 0x88, 0x39, 0x5b, 0x25, 0x26, 0x39, 0x1a, 0x72, 0x49, 0x96, 0xa4, 0x41, 0x56,
                0xbe, 0xac, 0x80, 0x82,
            ]),
            Sha256Digest::from([
                0x12, 0x85, 0x87, 0x92, 0xbf, 0x8e, 0x74, 0xcb, 0xa4, 0x9d, 0xee, 0x5e, 0x88, 0x12,
                0xe0, 0x19, 0xda, 0x87, 0x45, 0x4b, 0xff, 0x9e, 0x84, 0x7e, 0xd8, 0x3d, 0xb0, 0x7a,
                0xf3, 0x13, 0x74, 0x30,
            ]),
            Sha256Digest::from([
                0x82, 0xf8, 0x80, 0xa2, 0x78, 0xf6, 0x82, 0xc2, 0xbd, 0x0a, 0xd6, 0x88, 0x7c, 0xb5,
                0x9f, 0x65, 0x2e, 0x15, 0x59, 0x87, 0xd6, 0x1b, 0xbf, 0x6a, 0x88, 0xd3, 0x6e, 0xe9,
                0x3b, 0x60, 0x72, 0xe6,
            ]),
            Sha256Digest::from([
                0x65, 0x6d, 0x9c, 0xcb, 0xaa, 0xe3, 0xd6, 0x55, 0x85, 0x2e, 0x38, 0xde, 0xb3, 0xa2,
                0xdc, 0xf8, 0x05, 0x8d, 0xc9, 0xfb, 0x6f, 0x2a, 0xb3, 0xd3, 0xb3, 0x53, 0x9e, 0xb7,
                0x7b, 0x24, 0x8a, 0x66,
            ]),
            Sha256Digest::from([
                0x10, 0x91, 0xd0, 0x5e, 0xb6, 0xe2, 0xf2, 0x97, 0x77, 0x4f, 0xe6, 0x05, 0x35, 0x98,
                0x45, 0x7c, 0xc6, 0x19, 0x08, 0x31, 0x8d, 0xe4, 0xb8, 0x26, 0xf0, 0xfc, 0x86, 0xd4,
                0xbb, 0x11, 0x7d, 0x33,
            ]),
            Sha256Digest::from([
                0xe8, 0x65, 0xaa, 0x80, 0x50, 0x09, 0xcc, 0x29, 0x18, 0xd9, 0xc2, 0xf8, 0x40, 0xc4,
                0xda, 0x43, 0xa7, 0x03, 0xad, 0x9f, 0x5b, 0x58, 0x06, 0x16, 0x3d, 0x71, 0x61, 0x69,
                0x6b, 0x5a, 0x0a, 0xdc,
            ]),
        ];

        let final_path: [Sha256Digest; 5] = [
            Sha256Digest::from([
                0xd5, 0xc0, 0xd1, 0xbe, 0xbb, 0x06, 0x04, 0x8e, 0xd6, 0xfe, 0x2e, 0xf2, 0xc6, 0xce,
                0xf3, 0x05, 0xb3, 0xed, 0x63, 0x39, 0x41, 0xeb, 0xc8, 0xb3, 0xbe, 0xc9, 0x73, 0x87,
                0x54, 0xcd, 0xdd, 0x60,
            ]),
            Sha256Digest::from([
                0xe1, 0x92, 0x0a, 0xda, 0x52, 0xf4, 0x3d, 0x05, 0x5b, 0x50, 0x31, 0xce, 0xe6, 0x19,
                0x25, 0x20, 0xd6, 0xa5, 0x11, 0x55, 0x14, 0x85, 0x1c, 0xe7, 0xfd, 0x44, 0x8d, 0x4a,
                0x39, 0xfa, 0xe2, 0xab,
            ]),
            Sha256Digest::from([
                0x23, 0x35, 0xb5, 0x25, 0xf4, 0x84, 0xe9, 0xb4, 0x0d, 0x6a, 0x4a, 0x96, 0x93, 0x94,
                0x84, 0x3b, 0xdc, 0xf6, 0xd1, 0x4c, 0x48, 0xe8, 0x01, 0x5e, 0x08, 0xab, 0x92, 0x66,
                0x2c, 0x05, 0xc6, 0xe9,
            ]),
            Sha256Digest::from([
                0xf9, 0x0b, 0x65, 0xa7, 0xa6, 0x20, 0x16, 0x89, 0x99, 0x9f, 0x32, 0xbf, 0xd3, 0x68,
                0xe5, 0xe3, 0xec, 0x9c, 0xb7, 0x0a, 0xc7, 0xb8, 0x39, 0x90, 0x03, 0xf1, 0x75, 0xc4,
                0x08, 0x85, 0x08, 0x1a,
            ]),
            Sha256Digest::from([
                0x09, 0xab, 0x30, 0x34, 0x91, 0x1f, 0xe1, 0x25, 0x63, 0x10, 0x51, 0xdf, 0x04, 0x08,
                0xb3, 0x94, 0x6b, 0x0b, 0xde, 0x79, 0x09, 0x11, 0xe8, 0x97, 0x8b, 0xa0, 0x7d, 0xd5,
                0x6c, 0x73, 0xe7, 0xee,
            ]),
        ];

        let final_ots_sig = LmotsSignature {
            ots_type: LmotsAlgorithmType::LmotsSha256N32W8,
            nonce: final_c,
            y: final_y,
        };

        let final_lms_sig = LmsSignature {
            q: lms_q,
            lmots_signature: final_ots_sig,
            sig_type: LmsAlgorithmType::LmsSha256N32H5,
            lms_path: Vec::from(final_path),
        };

        let final_thingie = verify_lms_signature(
            5,
            &LmotsAlgorithmType::LmotsSha256N32W8,
            &message,
            &lms_public_identifier,
            lms_q,
            &lms_public_key,
            &final_lms_sig,
        ).unwrap();
        assert!(final_thingie);
        println!("Final thingie is {}", final_thingie);
    }

    #[test]
    fn test_many_24() {
        let message = "this is the message I want signed".as_bytes();
        let the_lms_type = &LmsAlgorithmType::LmsSha256N24H10;
        let the_ots_type = &LmotsAlgorithmType::LmotsSha256N24W4;
        let (_, tree_height) = get_lms_parameters(the_lms_type);
        let (lms_identifier, initial_q, t_tree, private_keys) =
            create_lms_tree::<24, 51>(the_lms_type, the_ots_type).unwrap();
        let lms_public_key = t_tree[1];

        let num_keys = 1 << tree_height;
        let mut passed = 0;
        println!("About to perform {} sha256/192 sign and verifies", num_keys);
        for offset_q in 0..num_keys {
            let the_q_to_use = initial_q + offset_q;
            let lms_sig = lms_sign_message(
                the_ots_type,
                the_lms_type,
                message,
                &t_tree,
                tree_height,
                &private_keys[the_q_to_use as usize],
                &lms_identifier,
                the_q_to_use,
            ).unwrap();

            let valid = verify_lms_signature(
                tree_height,
                the_ots_type,
                message,
                &lms_identifier,
                the_q_to_use,
                &lms_public_key,
                &lms_sig,
            ).unwrap();
            if valid {
                passed += 1;
            }
            assert!(valid);
        }
        assert_eq!(passed, num_keys);
    }

    #[test]
    fn test_many_32() {
        let message = "this is the message I want signed".as_bytes();
        let the_lms_type = &LmsAlgorithmType::LmsSha256N32H10;
        let the_ots_type = &LmotsAlgorithmType::LmotsSha256N32W4;
        let (_, tree_height) = get_lms_parameters(the_lms_type);
        let (lms_identifier, initial_q, t_tree, private_keys) =
            create_lms_tree::<32, 67>(the_lms_type, the_ots_type).unwrap();
        let lms_public_key = t_tree[1];

        let num_keys = 1 << tree_height;
        let mut passed = 0;
        println!("About to perform {} sha256 sign and verifies", num_keys);
        for offset_q in 0..num_keys {
            let the_q_to_use = initial_q + offset_q;
            let lms_sig = lms_sign_message(
                the_ots_type,
                the_lms_type,
                message,
                &t_tree,
                tree_height,
                &private_keys[the_q_to_use as usize],
                &lms_identifier,
                the_q_to_use,
            ).unwrap();

            let valid = verify_lms_signature(
                tree_height,
                the_ots_type,
                message,
                &lms_identifier,
                the_q_to_use,
                &lms_public_key,
                &lms_sig,
            ).unwrap();
            if valid {
                passed += 1;
            }
            assert!(valid);
        }
        assert_eq!(passed, num_keys);
    }

    #[test]
    fn test_enum_lookup() {
        assert_eq!(
            LmotsAlgorithmType::from_i32(3).unwrap(),
            LmotsAlgorithmType::LmotsSha256N32W4
        );
        assert_eq!(
            lookup_lmots_algorithm_type(4).unwrap(),
            LmotsAlgorithmType::LmotsSha256N32W8
        );
        assert_eq!(lookup_lms_algorithm_type(3), None);
        assert_eq!(
            lookup_lms_algorithm_type(5).unwrap(),
            LmsAlgorithmType::LmsSha256N32H5
        );
        assert_eq!(
            lookup_lms_algorithm_type(6).unwrap(),
            LmsAlgorithmType::LmsSha256N32H10
        );
        assert_eq!(
            lookup_lms_algorithm_type(7).unwrap(),
            LmsAlgorithmType::LmsSha256N32H15
        );

        assert_eq!(
            lookup_lms_algorithm_type(10).unwrap(),
            LmsAlgorithmType::LmsSha256N24H5
        );
        assert_eq!(
            lookup_lms_algorithm_type(11).unwrap(),
            LmsAlgorithmType::LmsSha256N24H10
        );
        assert_eq!(
            lookup_lms_algorithm_type(12).unwrap(),
            LmsAlgorithmType::LmsSha256N24H15
        );
    }
}
